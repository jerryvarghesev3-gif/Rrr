ll



private val DosTarGzFileName = "firmware_imx6_d.tar.gz.enc"

override suspend fun evaluateFirmwareCompatibility(
    activeOsVersion: DYoctoOS,
    releaseManifest: SoftwareReleaseManifest,
): Outcome<DFirmwareCompatibilityStatus> {

    var containsOS = false
    var ospkgFound = false
    var pkgOsVersion = DYoctoOS.INVALID

    var shouldSendOsUpdate = false
    var appTarFound = false
    var error: DFirmwareCompatibilityStatus? = null

    // -------------------------
    // 1) OS tar check (use DosTarGzFileName - because DextractYoctoVersion checks this file)
    // -------------------------
    extractionFolder.listFiles()?.forEach { file ->
        if (file.name == DosTarGzFileName) {
            ospkgFound = true

            when (val ver = DextractYoctoVersion(file)) {
                is Outcome.Ok -> {
                    val pkgOs: SemVer? = SemVer.fromString(ver.value)
                    val deviceOs: SemVer? = SemVer.fromString(d.getOperatingSystemVersion().trim())

                    shouldSendOsUpdate = (pkgOs != null && deviceOs != null && pkgOs != deviceOs)

                    if (pkgOs != null) {
                        containsOS = shouldContainOS(pkgOs)
                        pkgOsVersion = DYoctoOS.fromVersion(pkgOs)
                    }
                }

                is Outcome.Error -> {
                    ProLog.e(
                        MODULE_NAME,
                        "Could not find yocto version in ${file.name}. Result: ${ver.error as String}"
                    )
                    error = DFirmwareCompatibilityStatus.Error
                }
            }
            return@forEach
        }
    }

    // -------------------------
    // 2) Verify dAppTar exists (do NOT delete OS tar)
    // -------------------------
    extractionFolder.listFiles()?.forEach { file ->
        if (file.name == dAppTar) {
            appTarFound = true
            if (pkgOsVersion == DYoctoOS.INVALID) {
                pkgOsVersion = DYoctoOS.DUNFELL
            }
            return@forEach
        }
    }

    // -------------------------
    // ✅ ONE FINAL RETURN
    // -------------------------
    val result =
        when {
            error != null ->
                Outcome.Error(error!!)

            !appTarFound -> {
                ProLog.e(MODULE_NAME, "dAppTar not found in extraction folder: $dAppTar")
                Outcome.Error(DFirmwareCompatibilityStatus.Error)
            }

            shouldSendOsUpdate ->
                Outcome.Ok(DFirmwareCompatibilityStatus.OSUpdateIncluded)

            else ->
                Outcome.Ok(DFirmwareCompatibilityStatus.OSUpdateNotIncluded)
        }

    return result
}






// Transfer all files
val packages = releaseManifest.centrellaPackages.firstOrNull()
if (packages == null) {
    cancel(FirmwareUpdateError.GENERAL_TRANSFER_ERROR)
    return@channelFlow
}

packages.centrellaComponents.forEach { component ->

    // ✅ SKIP OS TAR WHEN OS UPDATE NOT NEEDED
    if (component.fileName == DosTarGzFileName && !shouldSendOsUpdate) {
        ProLog.i(MODULE_NAME, "Skipping OS file (shouldSendOsUpdate=false): ${component.fileName}")
        return@forEach
    }

    val file = File(extractionFolder, component.fileName)
    if (!file.exists()) {
        cancel(FirmwareUpdateError.GENERAL_TRANSFER_ERROR)
        return@channelFlow
    }

    // ... keep your existing checks + upload logic unchanged ...
}






fun DextractYoctoVersion(targzFile: File): Outcome<String> {
    // ✅ If it’s not the DOS OS tar, just say "not applicable"
    if (targzFile.name != dosTarGzFileName) {
        return Outcome.Error("NOT_OS_TAR")   // or Outcome.Ok("") if you prefer
    }

    // existing DOS parsing logic below (unchanged)
    return when (val hillromVersion = searchTarGzFile(targzFile, "hillrom-version")) {
        is Outcome.Ok -> {
            val lines = hillromVersion.value.decodeToString()
                .split('\n')
                .map { it.trim() }

            var matchValue: String? = null
            lines.forEach { line ->
                if (line.contains("Version:")) {
                    val regex = Regex("\\d+(\\.\\d+)+")
                    matchValue = regex.find(line)?.value
                    return@forEach
                }
            }

            if (matchValue != null) Outcome.Ok(matchValue!!)
            else Outcome.Error("Failed to decode os version.")
        }

        is Outcome.Error -> Outcome.Error(hillromVersion.error as String)
    }
}
