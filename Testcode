private fun startCamera() {
    val cameraProviderFuture = ProcessCameraProvider.getInstance(this)

    cameraProviderFuture.addListener({
        val provider = cameraProviderFuture.get()

        val preview = Preview.Builder().build().also {
            it.setSurfaceProvider(previewView.surfaceProvider)
        }
        val selector = CameraSelector.DEFAULT_BACK_CAMERA

        val analysis = ImageAnalysis.Builder()
            .setBackpressureStrategy(ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)
            .build()

        // Inline analyzer (no BarcodeAnalyzer class needed)
        analysis.setAnalyzer(
            ContextCompat.getMainExecutor(this),
            ImageAnalysis.Analyzer { imageProxy ->
                val media = imageProxy.image ?: run { imageProxy.close(); return@Analyzer }
                val image = InputImage.fromMediaImage(
                    media, imageProxy.imageInfo.rotationDegrees
                )
                val scanner = BarcodeScanning.getClient(
                    BarcodeScannerOptions.Builder()
                        .setBarcodeFormats(Barcode.FORMAT_QR_CODE) // only QR if you want
                        .build()
                )
                scanner.process(image)
                    .addOnSuccessListener { barcodes ->
                        val text = barcodes.firstOrNull()?.rawValue
                        if (!text.isNullOrBlank() && scanning) {
                            scanning = false
                            bedId = text.trim()
                            txtInfo.text = "bedId: $bedId"
                            btnContinue.isEnabled = true
                        }
                    }
                    .addOnCompleteListener { imageProxy.close() }
            }
        )

        provider.unbindAll()
        provider.bindToLifecycle(this, selector, preview, analysis)
        previewView.visibility = View.VISIBLE
        txtInfo.text = "Aim at bedId QR"
    }, ContextCompat.getMainExecutor(this))
}





private fun startCamera() {
    val cameraProviderFuture = ProcessCameraProvider.getInstance(this)

    cameraProviderFuture.addListener({
        val provider = cameraProviderFuture.get()

        val preview = Preview.Builder().build().also {
            it.setSurfaceProvider(previewView.surfaceProvider)
        }
        val selector = CameraSelector.DEFAULT_BACK_CAMERA

        val analysis = ImageAnalysis.Builder()
            .setBackpressureStrategy(ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)
            .build()

        analysis.setAnalyzer(
            ContextCompat.getMainExecutor(this),
            ImageAnalysis.Analyzer { imageProxy ->
                val media = imageProxy.image ?: run { imageProxy.close(); return@Analyzer }
                val image = InputImage.fromMediaImage(
                    media, imageProxy.imageInfo.rotationDegrees
                )
                val scanner = BarcodeScanning.getClient(
                    BarcodeScannerOptions.Builder()
                        .setBarcodeFormats(Barcode.FORMAT_QR_CODE)
                        .build()
                )
                scanner.process(image)
                    .addOnSuccessListener { barcodes ->
                        val text = barcodes.firstOrNull()?.rawValue
                        if (!text.isNullOrBlank() && scanning) {
                            scanning = false
                            locationId = text.trim()
                            txtInfo.text = "locationId: $locationId"
                            btnAdd.isEnabled = true
                        }
                    }
                    .addOnCompleteListener { imageProxy.close() }
            }
        )

        provider.unbindAll()
        provider.bindToLifecycle(this, selector, preview, analysis)
        previewView.visibility = View.VISIBLE
        txtInfo.text = "Aim at locationId QR"
    }, ContextCompat.getMainExecutor(this))
}


















private fun scheduleTestAlarmExact() {
    val am = getSystemService(Context.ALARM_SERVICE) as AlarmManager
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
        if (!am.canScheduleExactAlarms()) {
            // Send user to settings to grant "Alarms & reminders"
            val intent = Intent(Settings.ACTION_REQUEST_SCHEDULE_EXACT_ALARM)
            startActivity(intent)
            // fall back to inexact for now
            scheduleTestAlarmInexact()
            return
        }
    }
    val pi = PendingIntent.getBroadcast(
        this, 0, Intent(this, AlarmReceiver::class.java),
        if (Build.VERSION.SDK_INT >= 23)
            PendingIntent.FLAG_IMMUTABLE or PendingIntent.FLAG_UPDATE_CURRENT
        else PendingIntent.FLAG_UPDATE_CURRENT
    )
    val triggerAt = System.currentTimeMillis() + 10_000
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
        am.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, triggerAt, pi)
    } else {
        am.setExact(AlarmManager.RTC_WAKEUP, triggerAt, pi)
    }
}





private fun scheduleTestAlarmInexact() {
    val am = getSystemService(Context.ALARM_SERVICE) as AlarmManager
    val pi = PendingIntent.getBroadcast(
        this, 0, Intent(this, AlarmReceiver::class.java),
        if (Build.VERSION.SDK_INT >= 23)
            PendingIntent.FLAG_IMMUTABLE or PendingIntent.FLAG_UPDATE_CURRENT
        else PendingIntent.FLAG_UPDATE_CURRENT
    )
    val triggerAt = System.currentTimeMillis() + 10_000
    am.set(AlarmManager.RTC_WAKEUP, triggerAt, pi)   // inexact → no crash
}













package com.connect.connection

import android.Manifest
import android.content.pm.PackageManager
import android.os.Build
import android.os.Bundle
import android.view.View
import android.widget.Button
import android.widget.TextView
import android.widget.Toast
import androidx.activity.ComponentActivity
import androidx.camera.core.CameraSelector
import androidx.camera.core.ImageAnalysis
import androidx.camera.core.Preview
import androidx.camera.lifecycle.ProcessCameraProvider
import androidx.camera.view.PreviewView
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat
import androidx.lifecycle.LifecycleOwner
import com.google.mlkit.vision.barcode.BarcodeScannerOptions
import com.google.mlkit.vision.barcode.common.Barcode
import com.google.mlkit.vision.barcode.BarcodeScanning
import com.google.mlkit.vision.common.InputImage
import org.eclipse.paho.client.mqttv3.IMqttActionListener
import org.eclipse.paho.client.mqttv3.IMqttDeliveryToken
import org.eclipse.paho.client.mqttv3.IMqttToken
import org.eclipse.paho.client.mqttv3.MqttCallbackExtended
import org.eclipse.paho.client.mqttv3.MqttMessage
import org.json.JSONObject
import java.util.concurrent.atomic.AtomicInteger

class QRBActivity : ComponentActivity() {

    // ---- UI ----
    private lateinit var previewView: PreviewView
    private lateinit var txtInfo: TextView
    private lateinit var btnAdd: Button
    private lateinit var btnCancel: Button
    private lateinit var btnRescan: Button

    // ---- Flow data ----
    private lateinit var gatewayId: String
    private lateinit var bedId: String
    private var locationId: String? = null
    private var scanning = true

    // ---- Topics (adjust aa/bb/cc path to match your backend) ----
    private fun topicSetLocationReq(gw: String) =
        "2.0/aa/bb/gateway/$gw/command/set_location/request"
    private fun topicSetLocationResp(bed: String) =
        "2.0/aa/bb/cc/$bed/command/set_location/response"

    // ---- Txn ----
    private val txnGen = AtomicInteger(200)
    private var lastTxnSetLoc = -1

    // ---- Small helper to ensure UI thread updates ----
    private fun ui(block: () -> Unit) = runOnUiThread(block)

    // ─────────────────────────────────────────────────────────────

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_qrb)

        gatewayId = intent.getStringExtra("gatewayId") ?: ""
        bedId     = intent.getStringExtra("bedId") ?: ""

        previewView = findViewById(R.id.previewViewB)
        txtInfo     = findViewById(R.id.qrTextB)
        btnAdd      = findViewById(R.id.btnAddB)
        btnCancel   = findViewById(R.id.btnCancelB)
        btnRescan   = findViewById(R.id.btnRescanB)

        btnAdd.isEnabled = false

        btnCancel.setOnClickListener { finish() }
        btnRescan.setOnClickListener {
            locationId = null
            txtInfo.text = "Aim at locationId QR"
            scanning = true
        }
        btnAdd.setOnClickListener { sendSetLocation() }

        ensureCameraThenStart()

        // MQTT: subscribe to response + set callbacks
        val client = MqttHolder.readyClientOrNull()
        if (client == null) {
            Toast.makeText(this, "MQTT not ready", Toast.LENGTH_LONG).show()
            finish(); return
        }

        client.subscribe(topicSetLocationResp(bedId), 1, /* userContext = */ null,
            object : IMqttActionListener {
                override fun onSuccess(asyncActionToken: IMqttToken?) { /* ok */ }
                override fun onFailure(asyncActionToken: IMqttToken?, exception: Throwable?) {
                    ui {
                        Toast.makeText(
                            this@QRBActivity,
                            "Subscribe failed: ${exception?.message ?: "unknown"}",
                            Toast.LENGTH_SHORT
                        ).show()
                    }
                }
            }
        )

        client.setCallback(object : MqttCallbackExtended {
            override fun connectComplete(reconnect: Boolean, serverURI: String?) {}
            override fun connectionLost(cause: Throwable?) {}
            override fun deliveryComplete(token: IMqttDeliveryToken?) {}
            override fun messageArrived(topic: String?, message: MqttMessage?) {
                if (topic == topicSetLocationResp(bedId)) {
                    // Parse & navigate from UI thread
                    ui { onSetLocationResp(message?.toString().orEmpty()) }
                }
            }
        })
    }

    // ───────────────── Camera / ML Kit ─────────────────

    private fun ensureCameraThenStart() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M &&
            ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA)
            != PackageManager.PERMISSION_GRANTED) {
            ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.CAMERA), 3002)
        } else startCamera()
    }

    private fun startCamera() {
        val cameraProviderFuture = ProcessCameraProvider.getInstance(this)
        cameraProviderFuture.addListener({
            val provider = cameraProviderFuture.get()

            val preview = Preview.Builder().build().also {
                it.setSurfaceProvider(previewView.surfaceProvider)
            }
            val selector = CameraSelector.DEFAULT_BACK_CAMERA

            val analysis = ImageAnalysis.Builder()
                .setBackpressureStrategy(ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)
                .build()

            analysis.setAnalyzer(
                ContextCompat.getMainExecutor(this),
                ImageAnalysis.Analyzer { imageProxy ->
                    val media = imageProxy.image ?: run { imageProxy.close(); return@Analyzer }
                    val image = InputImage.fromMediaImage(
                        media, imageProxy.imageInfo.rotationDegrees
                    )
                    val scanner = BarcodeScanning.getClient(
                        BarcodeScannerOptions.Builder()
                            .setBarcodeFormats(Barcode.FORMAT_QR_CODE) // QR only
                            .build()
                    )
                    scanner.process(image)
                        .addOnSuccessListener { barcodes ->
                            val text = barcodes.firstOrNull()?.rawValue
                            if (!text.isNullOrBlank() && scanning) {
                                scanning = false
                                locationId = text.trim()
                                txtInfo.text = "locationId: $locationId"
                                btnAdd.isEnabled = true
                            }
                        }
                        .addOnCompleteListener { imageProxy.close() }
                }
            )

            provider.unbindAll()
            provider.bindToLifecycle(this as LifecycleOwner, selector, preview, analysis)
            previewView.visibility = View.VISIBLE
            txtInfo.text = "Aim at locationId QR"
        }, ContextCompat.getMainExecutor(this))
    }

    override fun onRequestPermissionsResult(code: Int, perms: Array<out String>, res: IntArray) {
        super.onRequestPermissionsResult(code, perms, res)
        if (code == 3002 && res.isNotEmpty() && res[0] == PackageManager.PERMISSION_GRANTED) {
            startCamera()
        } else {
            Toast.makeText(this, "Camera permission required", Toast.LENGTH_LONG).show()
        }
    }

    // ───────────────── MQTT: publish + handle response ─────────────────

    private fun sendSetLocation() {
        val loc = locationId ?: run {
            ui { Toast.makeText(this, "Scan locationId first", Toast.LENGTH_SHORT).show() }
            return
        }

        val client = MqttHolder.readyClientOrNull()
            ?: run {
                ui { Toast.makeText(this, "Not connected", Toast.LENGTH_SHORT).show() }
                return
            }

        lastTxnSetLoc = txnGen.incrementAndGet()

        val data = JSONObject()
            .put("bb_id", bedId)
            .put("force", false)
            .put("location_id", loc)

        val req = JSONObject()
            .put("command_id", "set_location")
            .put("data", data)
            .put("reply_to", topicSetLocationResp(bedId))
            .put("transaction_id", lastTxnSetLoc)

        val payload = req.toString().toByteArray(Charsets.UTF_8)

        // Use byte[] overload + userContext = null → avoids Parcelable crash
        client.publish(
            topicSetLocationReq(gatewayId),
            payload,
            /* qos = */ 1,
            /* retained = */ false,
            /* userContext = */ null,
            /* callback = */ object : IMqttActionListener {
                override fun onSuccess(asyncActionToken: IMqttToken?) {
                    ui { txtInfo.text = "Sent set_location (tx=$lastTxnSetLoc)…" }
                }
                override fun onFailure(asyncActionToken: IMqttToken?, exception: Throwable?) {
                    ui {
                        Toast.makeText(
                            this@QRBActivity,
                            "Publish failed: ${exception?.message ?: "unknown error"}",
                            Toast.LENGTH_SHORT
                        ).show()
                    }
                }
            }
        )
    }

    private fun onSetLocationResp(json: String) {
        try {
            val obj = JSONObject(json)
            val tx = obj.optInt("transaction_id", -1)
            if (tx != lastTxnSetLoc) return

            val status = obj.optInt("status", -1)
            val resultLoc = obj.optJSONObject("data")
                ?.optJSONObject("location")
                ?.optString("id") ?: locationId.orEmpty()

            startActivity(
                android.content.Intent(this, SummaryActivity::class.java)
                    .putExtra("status", status)
                    .putExtra("gatewayId", gatewayId)
                    .putExtra("bedId", bedId)
                    .putExtra("locationId", resultLoc)
            )
            finish()
        } catch (t: Throwable) {
            Toast.makeText(this, "Bad response: ${t.message}", Toast.LENGTH_SHORT).show()
        }
    }
}



