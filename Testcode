private fun load(appContext: Context) {
    loadJob?.cancel()

    loadJob = viewModelScope.launch {

        // ✅ Always stop previous state first (prevents infinite loading)
        hardStopAndDisconnect()

        // ✅ 1) USB + permission FIRST (this triggers popup if needed)
        val dev = getFirstUsbDevice(appContext)
        if (dev == null) {
            updateState {
                it.copy(
                    loadingStatus = LoadingStatus.Error,
                    incompatibleProductDialogVisible = true,
                    incompatibleProductMessage = "No USB device detected."
                )
            }
            return@launch
        }

        val usbManager = appContext.getSystemService(Context.USB_SERVICE) as UsbManager
        if (!usbManager.hasPermission(dev)) {
            requestUsbPermission(appContext, dev)
            updateState {
                it.copy(
                    loadingStatus = LoadingStatus.Error,
                    incompatibleProductDialogVisible = true,
                    incompatibleProductMessage = "USB permission required. Please tap Allow."
                )
            }
            return@launch
        }

        // ✅ 2) Detect product BEFORE connect
        val text = "${dev.productName} ${dev.manufacturerName}".uppercase()
        val detected = when {
            text.contains("P80") -> MedDevices.DYNAMO
            text.contains("P79") -> MedDevices.CENTRELLA
            else -> null
        }

        if (detected != null && detected != MedDevices.CENTRELLA) {
            updateState {
                it.copy(
                    loadingStatus = LoadingStatus.Error,
                    incompatibleProductDialogVisible = true,
                    incompatibleProductMessage = "Wrong product connected. Please connect to Centrella.",
                    suppressDisconnectModal = true
                )
            }
            // ✅ make sure connection is not left half-open
            hardStopAndDisconnect()
            return@launch
        }

        // ✅ 3) NOW connect (only for valid product)
        if (!connectionBloc.isConnected()) {
            updateState { it.copy(loadingStatus = LoadingStatus.Connecting) }

            if (connectionBloc.connect(GN2_Address.SYS_DIAG) is Outcome.Error) {
                updateState { it.copy(loadingStatus = LoadingStatus.Error) }
                return@launch
            }
        }

        // ✅ 4) Only after valid + connected
        deviceBloc.startBoardCollection()
        loadProperties()
        deviceBloc.startBedStatusPoll()
    }
}












if (isDecryptPresent)
{
    const QString decryptFileName = "decrypt";

    // IMPORTANT: don't modify binPath in-place
    QString decryptPath = binPath;
    decryptPath.replace(somFileName, decryptFileName);

    FirmwareUpdateCAN* fw1 = new FirmwareUpdateCAN();
    fw1->setImageData(decryptPath);
    fw1->onChangedSelectedServer(addressForUpdate, serverBoard, NULL);
    fw1->setDestination(destination);

    MEM_SendImageFileNameRequest  req1 = MEM_SendImageFileNameRequest_init_zero;
    MEM_SendImageFileNameResponse rsp1 = MEM_SendImageFileNameResponse_init_zero;
    req1.memoryType = memoryType;

    // send the decrypt filename (NOT somFileName)
    memset(req1.imageName, 0, sizeof(req1.imageName));
    QByteArray dn = decryptFileName.toUtf8();
    memcpy(req1.imageName, dn.constData(),
           std::min((int)sizeof(req1.imageName) - 1, dn.size()));

    ProLog().i(MODULE_NAME, "Downloading " + std::string(req1.imageName) + " to SOM");

    if (CMD_OK != MEM_SendImageFileName(GN2A_SOM, &req1, &rsp1))
    {
        ProLog().w(MODULE_NAME, "Could not send decrypt file info to " + board.toStdString());
        onBoardUpgraded(fw1, destination, false);
        return;
    }
}
