private fun startCamera() {
    val cameraProviderFuture = ProcessCameraProvider.getInstance(this)

    cameraProviderFuture.addListener({
        val provider = cameraProviderFuture.get()

        val preview = Preview.Builder().build().also {
            it.setSurfaceProvider(previewView.surfaceProvider)
        }
        val selector = CameraSelector.DEFAULT_BACK_CAMERA

        val analysis = ImageAnalysis.Builder()
            .setBackpressureStrategy(ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)
            .build()

        // Inline analyzer (no BarcodeAnalyzer class needed)
        analysis.setAnalyzer(
            ContextCompat.getMainExecutor(this),
            ImageAnalysis.Analyzer { imageProxy ->
                val media = imageProxy.image ?: run { imageProxy.close(); return@Analyzer }
                val image = InputImage.fromMediaImage(
                    media, imageProxy.imageInfo.rotationDegrees
                )
                val scanner = BarcodeScanning.getClient(
                    BarcodeScannerOptions.Builder()
                        .setBarcodeFormats(Barcode.FORMAT_QR_CODE) // only QR if you want
                        .build()
                )
                scanner.process(image)
                    .addOnSuccessListener { barcodes ->
                        val text = barcodes.firstOrNull()?.rawValue
                        if (!text.isNullOrBlank() && scanning) {
                            scanning = false
                            bedId = text.trim()
                            txtInfo.text = "bedId: $bedId"
                            btnContinue.isEnabled = true
                        }
                    }
                    .addOnCompleteListener { imageProxy.close() }
            }
        )

        provider.unbindAll()
        provider.bindToLifecycle(this, selector, preview, analysis)
        previewView.visibility = View.VISIBLE
        txtInfo.text = "Aim at bedId QR"
    }, ContextCompat.getMainExecutor(this))
}





private fun startCamera() {
    val cameraProviderFuture = ProcessCameraProvider.getInstance(this)

    cameraProviderFuture.addListener({
        val provider = cameraProviderFuture.get()

        val preview = Preview.Builder().build().also {
            it.setSurfaceProvider(previewView.surfaceProvider)
        }
        val selector = CameraSelector.DEFAULT_BACK_CAMERA

        val analysis = ImageAnalysis.Builder()
            .setBackpressureStrategy(ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)
            .build()

        analysis.setAnalyzer(
            ContextCompat.getMainExecutor(this),
            ImageAnalysis.Analyzer { imageProxy ->
                val media = imageProxy.image ?: run { imageProxy.close(); return@Analyzer }
                val image = InputImage.fromMediaImage(
                    media, imageProxy.imageInfo.rotationDegrees
                )
                val scanner = BarcodeScanning.getClient(
                    BarcodeScannerOptions.Builder()
                        .setBarcodeFormats(Barcode.FORMAT_QR_CODE)
                        .build()
                )
                scanner.process(image)
                    .addOnSuccessListener { barcodes ->
                        val text = barcodes.firstOrNull()?.rawValue
                        if (!text.isNullOrBlank() && scanning) {
                            scanning = false
                            locationId = text.trim()
                            txtInfo.text = "locationId: $locationId"
                            btnAdd.isEnabled = true
                        }
                    }
                    .addOnCompleteListener { imageProxy.close() }
            }
        )

        provider.unbindAll()
        provider.bindToLifecycle(this, selector, preview, analysis)
        previewView.visibility = View.VISIBLE
        txtInfo.text = "Aim at locationId QR"
    }, ContextCompat.getMainExecutor(this))
}


















private fun scheduleTestAlarmExact() {
    val am = getSystemService(Context.ALARM_SERVICE) as AlarmManager
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
        if (!am.canScheduleExactAlarms()) {
            // Send user to settings to grant "Alarms & reminders"
            val intent = Intent(Settings.ACTION_REQUEST_SCHEDULE_EXACT_ALARM)
            startActivity(intent)
            // fall back to inexact for now
            scheduleTestAlarmInexact()
            return
        }
    }
    val pi = PendingIntent.getBroadcast(
        this, 0, Intent(this, AlarmReceiver::class.java),
        if (Build.VERSION.SDK_INT >= 23)
            PendingIntent.FLAG_IMMUTABLE or PendingIntent.FLAG_UPDATE_CURRENT
        else PendingIntent.FLAG_UPDATE_CURRENT
    )
    val triggerAt = System.currentTimeMillis() + 10_000
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
        am.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, triggerAt, pi)
    } else {
        am.setExact(AlarmManager.RTC_WAKEUP, triggerAt, pi)
    }
}





private fun scheduleTestAlarmInexact() {
    val am = getSystemService(Context.ALARM_SERVICE) as AlarmManager
    val pi = PendingIntent.getBroadcast(
        this, 0, Intent(this, AlarmReceiver::class.java),
        if (Build.VERSION.SDK_INT >= 23)
            PendingIntent.FLAG_IMMUTABLE or PendingIntent.FLAG_UPDATE_CURRENT
        else PendingIntent.FLAG_UPDATE_CURRENT
    )
    val triggerAt = System.currentTimeMillis() + 10_000
    am.set(AlarmManager.RTC_WAKEUP, triggerAt, pi)   // inexact â†’ no crash
}



