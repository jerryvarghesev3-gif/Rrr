private const val TAR_GZ = ".tar.gz"
private const val ENC = ".enc"

private fun File.isTarGzOrEnc(): Boolean =
    name.endsWith(TAR_GZ) || name.endsWith(TAR_GZ + ENC)

/**
 * If file is *.tar.gz.enc, decrypt it to a temp *.tar.gz and return that.
 * Otherwise return the original file.
 *
 * TODO: implement your real decryption in `decryptEncFileTo`.
 */
private fun maybeDecryptToTemp(tarOrEnc: File): File {
    if (!tarOrEnc.name.endsWith(TAR_GZ + ENC)) return tarOrEnc

    val out = File.createTempFile(tarOrEnc.name.removeSuffix(ENC), null, tarOrEnc.parentFile)
    // ensures .tar.gz suffix on the temp output
    val normalized = if (out.name.endsWith(TAR_GZ)) out else File(out.parentFile, out.name + TAR_GZ)

    decryptEncFileTo(tarOrEnc, normalized)   // <-- implement with your AES/GCM/etc.
    normalized.deleteOnExit()
    return normalized
}

/** Stub – replace with your actual decryption */
private fun decryptEncFileTo(encFile: File, plainOut: File) {
    encFile.inputStream().use { `in` ->
        plainOut.outputStream().use { out ->
            // TODO: Replace with real decryption (key/iv/source).
            // For now this throws so you don’t forget to wire it up.
            throw IllegalStateException("decryptEncFileTo() not implemented")
        }
    }
}








private fun searchTarGzFile(targzFile2Search: File, searchFileName: String): Outcome<ByteArray> {
    if (!(targzFile2Search.exists() && targzFile2Search.isTarGzOrEnc())) {
        return Outcome.Error("${targzFile2Search.name} invalid input")
    }

    val usable = maybeDecryptToTemp(targzFile2Search) // decrypt if *.enc

    return searchTarGzFile(
        TarInputStream(GZIPInputStream(usable.inputStream())),
        searchFileName
    )
}





private fun searchTarGzFile(
    targzFile2Search: File,
    secondaryTarGzFileName: String,
    searchFileName: String
): Outcome<ByteArray> {

    var outcome: Outcome<ByteArray> = Outcome.Error("${targzFile2Search.name} or $secondaryTarGzFileName invalid input")

    if (targzFile2Search.exists() && targzFile2Search.isTarGzOrEnc()
        && (secondaryTarGzFileName.endsWith(TAR_GZ) || secondaryTarGzFileName.endsWith(TAR_GZ + ENC))) {

        val outer = maybeDecryptToTemp(targzFile2Search)

        outcome = when (val found = searchTarGzFile(
            TarInputStream(GZIPInputStream(outer.inputStream())),
            secondaryTarGzFileName.removeSuffix(ENC) // allow either name inside
        )) {
            is Outcome.Ok -> {
                val innerTar = maybeDecryptToTemp(
                    // write found.value to a temp file so we can open it
                    File.createTempFile("inner-", TAR_GZ).apply {
                        outputStream().use { it.write(found.value) }
                        deleteOnExit()
                    }
                )
                searchTarGzFile(
                    TarInputStream(GZIPInputStream(innerTar.inputStream())),
                    searchFileName
                )
            }
            is Outcome.Error -> Outcome.Error("secondaryTarGzFileName search error: ${found.error as String}")
        }
    }
    return outcome
}




