ll


fun DynamoextractYoctoVersion(targzFile: File): Outcome<String> {
    var outcome: Outcome<String> =
        Outcome.Error("${targzFile.name} invalid input")

    // Only accept things that look like firmware tarballs
    if (!targzFile.name.isTarGzLike()) {
        return outcome
    }

    // Try to read the hillrom-version file from the archive
    when (val hillromVersion =
        searchTarGzFile(targzFile, HILLROM_VERSION_FILE)) {

        is Outcome.Ok -> {
            val lines = hillromVersion.value
                .decodeToString()
                .split('\n')
                .map { it.trim() }

            // Look for a line that contains "Version:"
            for (line in lines) {
                if (!line.contains("Version:", ignoreCase = true)) continue

                val regex  = Regex("\\d+(?:\\.\\d+)+")
                val match  = regex.find(line)?.value

                outcome = if (match != null) {
                    ProLog.i(
                        MODULE_NAME,
                        "${targzFile.name} OS version = $match"
                    )
                    Outcome.Ok(match)
                } else {
                    ProLog.e(MODULE_NAME, "Failed to decode OS version.")
                    Outcome.Error("Failed to decode OS version.")
                }

                // Stop after first Version line
                break
            }

            // No line with "Version:" found
            if (outcome is Outcome.Error) {
                ProLog.e(
                    MODULE_NAME,
                    "Failed to decode OS version (no Version line)."
                )
            }
        }

        is Outcome.Error -> {
            // Propagate underlying error from searchTarGzFile
            outcome = Outcome.Error(hillromVersion.error as String)
        }
    }

    return outcome
}













override suspend fun evaluateFirmwareCompatibility(
    activeOsVersion: DynamoYoctoOS,
    releaseManifest: SoftwareReleaseManifest,
): Outcome<DynamoFirmwareCompatibilityStatus> {

    var containsOS   = false
    var ospkgFound   = false
    var pkgOsVersion = DynamoYoctoOS.INVALID

    // 1) Look for the SOM OS package inside the extracted BAS
    extractionFolder.listFiles()?.forEach { file: File ->

        // We only care about firmware_imx* tarballs (tar.gz or tar.gz.enc)
        if (!file.name.startsWith("firmware_imx", ignoreCase = true)) return@forEach
        if (!file.name.isTarGzLike()) return@forEach

        ospkgFound = true

        when (val ver = DynamoextractYoctoVersion(file)) {
            is Outcome.Ok -> {
                // Parse semantic version from the string extracted above
                lastEvaluatedFwUpdateOsVersion = SemVer.fromString(ver.value)

                // Whether this BAS is supposed to contain OS (your existing logic)
                containsOS = shouldContainOS(lastEvaluatedFwUpdateOsVersion)

                // Map version → enum
                pkgOsVersion =
                    DynamoYoctoOS.fromVersion(lastEvaluatedFwUpdateOsVersion)
            }

            is Outcome.Error -> {
                ProLog.e(
                    MODULE_NAME,
                    "Could not find yocto version in ${file.name}. " +
                        "Result: ${ver.error as String}"
                )
                return Outcome.Error(DynamoFirmwareCompatibilityStatus.Error)
            }
        }

        // We only ever need the first matching OS package
        return@forEach
    }

    // Optional legacy fallback: detect SOM app tar when version parsing failed
    if (pkgOsVersion == DynamoYoctoOS.INVALID) {
        extractionFolder.listFiles()?.forEach { file: File ->
            if (file.name == dynamoAppTar) {   // keep your existing constant
                pkgOsVersion = DynamoYoctoOS.DUNFELL
                return@forEach
            }
        }
    }

    // 2) Decide overall compatibility status

    // No understandable OS update in this BAS
    if (!ospkgFound || !containsOS || pkgOsVersion == DynamoYoctoOS.INVALID) {
        return Outcome.Ok(
            DynamoFirmwareCompatibilityStatus.OSUpdateNotIncluded
        )
    }

    // OS is included – decide if update is required
    val status = if (pkgOsVersion <= activeOsVersion) {
        DynamoFirmwareCompatibilityStatus.UpdateNotRequired
    } else {
        DynamoFirmwareCompatibilityStatus.OSUpdateIncluded
    }

    return Outcome.Ok(status)
}







override suspend fun evaluateFirmwareCompatibility(
    activeOsVersion: DynamoYoctoOS,
    releaseManifest: SoftwareReleaseManifest,
): Outcome<DynamoFirmwareCompatibilityStatus> {

    var containsOS   = false
    var ospkgFound   = false
    var pkgOsVersion = DynamoYoctoOS.INVALID

    // 1) Look for the SOM OS package inside the extracted BAS
    extractionFolder.listFiles()?.forEach { file: File ->

        // We only care about firmware_imx* tarballs (tar.gz or tar.gz.enc)
        if (!file.name.startsWith("firmware_imx", ignoreCase = true)) return@forEach
        if (!file.name.isTarGzLike()) return@forEach

        ospkgFound = true

        when (val ver = DynamoextractYoctoVersion(file)) {
            is Outcome.Ok -> {
                // Parse semantic version from the string extracted above
                lastEvaluatedFwUpdateOsVersion = SemVer.fromString(ver.value)

                // Whether this BAS is supposed to contain OS (your existing logic)
                containsOS = shouldContainOS(lastEvaluatedFwUpdateOsVersion)

                // Map version → enum
                pkgOsVersion =
                    DynamoYoctoOS.fromVersion(lastEvaluatedFwUpdateOsVersion)
            }

            is Outcome.Error -> {
                ProLog.e(
                    MODULE_NAME,
                    "Could not find yocto version in ${file.name}. " +
                        "Result: ${ver.error as String}"
                )
                return Outcome.Error(DynamoFirmwareCompatibilityStatus.Error)
            }
        }

        // We only ever need the first matching OS package
        return@forEach
    }

    // Optional legacy fallback: detect SOM app tar when version parsing failed
    if (pkgOsVersion == DynamoYoctoOS.INVALID) {
        extractionFolder.listFiles()?.forEach { file: File ->
            if (file.name == dynamoAppTar) {   // keep your existing constant
                pkgOsVersion = DynamoYoctoOS.DUNFELL
                return@forEach
            }
        }
    }

    // 2) Decide overall compatibility status

    // No understandable OS update in this BAS
    if (!ospkgFound || !containsOS || pkgOsVersion == DynamoYoctoOS.INVALID) {
        return Outcome.Ok(
            DynamoFirmwareCompatibilityStatus.OSUpdateNotIncluded
        )
    }

    // OS is included – decide if update is required
    val status = if (pkgOsVersion <= activeOsVersion) {
        DynamoFirmwareCompatibilityStatus.UpdateNotRequired
    } else {
        DynamoFirmwareCompatibilityStatus.OSUpdateIncluded
    }

    return Outcome.Ok(status)
}
