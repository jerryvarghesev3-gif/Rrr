package com.connect.connection

import android.content.Intent
import android.net.Uri
import android.os.Bundle
import android.widget.Button
import android.widget.ImageView
import android.widget.TextView
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import org.eclipse.paho.client.mqttv3.IMqttActionListener
import org.eclipse.paho.client.mqttv3.IMqttDeliveryToken
import org.eclipse.paho.client.mqttv3.IMqttToken
import org.eclipse.paho.client.mqttv3.MqttCallbackExtended
import org.eclipse.paho.client.mqttv3.MqttMessage
import org.json.JSONObject

class SummaryBActivity : AppCompatActivity() {

    // UI
    private lateinit var txtGateway: TextView
    private lateinit var txtBed: TextView
    private lateinit var txtLocation: TextView
    private lateinit var txtInfo: TextView
    private lateinit var imgPreview: ImageView
    private lateinit var btnRescan: Button
    private lateinit var btnCancel: Button
    private lateinit var btnContinue: Button

    // data
    private var gatewayId = ""
    private var bedId = ""
    private var locationId = ""
    private var imageUri: Uri? = null

    private var responseTopic: String? = null
    private var lastTxnSetLoc: Int = 0

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_summary_b)

        // bind
        txtGateway  = findViewById(R.id.txtGatewayB)
        txtBed      = findViewById(R.id.txtBedB)
        txtLocation = findViewById(R.id.txtLocationB)
        txtInfo     = findViewById(R.id.txtInfoB)
        imgPreview  = findViewById(R.id.imgPreviewB)
        btnRescan   = findViewById(R.id.btnRescanB)
        btnCancel   = findViewById(R.id.btnCancelB)
        btnContinue = findViewById(R.id.btnContinueB)

        // read extras from BActivity
        gatewayId  = intent.getStringExtra(QRActivity.EXTRA_GATEWAY).orEmpty()
        bedId      = intent.getStringExtra(QRActivity.EXTRA_BED).orEmpty()
        locationId = intent.getStringExtra(QRActivity.EXTRA_LOCATION).orEmpty()
        intent.getStringExtra(QRActivity.EXTRA_IMAGE_URI)?.let { imageUri = Uri.parse(it) }

        // show
        txtGateway.text  = "Gateway: $gatewayId"
        txtBed.text      = "Bed ID: $bedId"
        txtLocation.text = "Location ID: $locationId"
        imageUri?.let { imgPreview.setImageURI(it) }

        // UI actions
        btnRescan.setOnClickListener { finish() }           // go back to scanner
        btnCancel.setOnClickListener { finish() }           // cancel same as back

        btnContinue.setOnClickListener {
            if (gatewayId.isEmpty() || bedId.isEmpty() || locationId.isEmpty()) {
                Toast.makeText(this, "Missing IDs", Toast.LENGTH_SHORT).show()
                return@setOnClickListener
            }
            txtInfo.text = "Setting location…"
            btnContinue.isEnabled = false
            subscribeForReplyAndSend()
        }
    }

    // ---------- MQTT flow (copy of old QRBActivity, adapted here) ----------

    private fun subscribeForReplyAndSend(force: Boolean = false) {
        val c = MqttHolder.readyClientOrNull() ?: run {
            txtInfo.text = "MQTT not connected"
            btnContinue.isEnabled = true
            return
        }

        val resp = topicSetLocationResp(bedId)
        responseTopic = resp

        // 1) subscribe (idempotent if already subscribed)
        c.subscribe(resp, 1, null, object : IMqttActionListener {
            override fun onSuccess(asyncActionToken: IMqttToken?) {
                // 2) after subscribe, install a callback that filters by topic and handles JSON
                c.setCallback(object : MqttCallbackExtended {
                    override fun connectComplete(reconnect: Boolean, serverURI: String?) {}
                    override fun connectionLost(cause: Throwable?) {}
                    override fun messageArrived(topic: String?, message: MqttMessage?) {
                        if (topic == responseTopic) {
                            val payload = message?.toString().orEmpty()
                            runOnUiThread { handleSetLocationResponse(payload) }
                        }
                    }
                    override fun deliveryComplete(token: IMqttDeliveryToken?) {}
                })
                // 3) publish the set_location request
                publishSetLocation(force)
            }
            override fun onFailure(asyncActionToken: IMqttToken?, exception: Throwable?) {
                txtInfo.text = "Subscribe failed: ${exception?.message}"
                btnContinue.isEnabled = true
            }
        })
    }

    private fun publishSetLocation(force: Boolean) {
        val c = MqttHolder.readyClientOrNull() ?: run {
            txtInfo.text = "MQTT not connected"
            btnContinue.isEnabled = true
            return
        }

        val reqTopic = topicSetLocationReq(gatewayId)

        lastTxnSetLoc += 1

        val data = JSONObject().apply {
            put("bed_id", bedId)                // keep field names same as old code
            put("force", force)
            put("location_id", locationId)
        }
        val req = JSONObject().apply {
            put("command", "set_location")
            put("data", data)
            put("reply_to", topicSetLocationResp(bedId))
            put("transaction_id", lastTxnSetLoc)
        }
        val payload = req.toString().toByteArray(Charsets.UTF_8)

        c.publish(reqTopic, payload, 1, false, null, object : IMqttActionListener {
            override fun onSuccess(asyncActionToken: IMqttToken?) {
                txtInfo.text = "Waiting for response…"
            }
            override fun onFailure(asyncActionToken: IMqttToken?, exception: Throwable?) {
                txtInfo.text = "Publish failed: ${exception?.message}"
                btnContinue.isEnabled = true
            }
        })
    }

    // Parse reply JSON and navigate to final SummaryActivity
    private fun handleSetLocationResponse(json: String) {
        try {
            val root = JSONObject(json)
            val status = root.optInt("status", -1)
            val locFromResp =
                root.optJSONObject("data")
                    ?.optString("locationId")
                    ?.takeIf { it.isNotBlank() }
            val finalLoc = locFromResp ?: locationId

            val i = Intent(this, SummaryActivity::class.java).apply {
                putExtra("gatewayId", gatewayId)
                putExtra("bedId", bedId)
                putExtra("locationId", finalLoc)
                putExtra("status", status)
            }
            startActivity(i)
            finish()
        } catch (t: Throwable) {
            txtInfo.text = "Response parse error: ${t.message}"
            btnContinue.isEnabled = true
        }
    }

    // topic helpers (match your old names)
    private fun topicSetLocationReq(gw: String)  = "gw/$gw/req/set_location"
    private fun topicSetLocationResp(bed: String) = "bed/$bed/resp/set_location"

    override fun onDestroy() {
        super.onDestroy()
        // best-effort cleanup
        try {
            val c = MqttHolder.readyClientOrNull()
            responseTopic?.let { topic -> c?.unsubscribe(topic) }
            // Paho doesn't allow setCallback(null); replace with a do-nothing callback
            c?.setCallback(object : MqttCallbackExtended {
                override fun connectComplete(reconnect: Boolean, serverURI: String?) {}
                override fun connectionLost(cause: Throwable?) {}
                override fun messageArrived(topic: String?, message: MqttMessage?) {}
                override fun deliveryComplete(token: IMqttDeliveryToken?) {}
            })
        } catch (_: Exception) { }
    }
}







<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:padding="16dp"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <ImageView
        android:id="@+id/imgPreviewB"
        android:layout_width="match_parent"
        android:layout_height="180dp"
        android:scaleType="centerCrop"
        android:background="#222" />

    <TextView
        android:id="@+id/txtGatewayB"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Gateway:"
        android:textSize="18sp"
        android:paddingTop="12dp"/>

    <TextView
        android:id="@+id/txtBedB"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Bed ID:"
        android:textSize="18sp"/>

    <TextView
        android:id="@+id/txtLocationB"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Location ID:"
        android:textSize="18sp"/>

    <TextView
        android:id="@+id/txtInfoB"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text=""
        android:paddingTop="8dp"/>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:gravity="end"
        android:paddingTop="16dp">

        <Button
            android:id="@+id/btnRescanB"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Rescan"/>

        <Button
            android:id="@+id/btnCancelB"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Cancel"
            android:layout_marginStart="12dp"/>

        <Button
            android:id="@+id/btnContinueB"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Continue"
            android:layout_marginStart="12dp"/>
    </LinearLayout>

</LinearLayout>







