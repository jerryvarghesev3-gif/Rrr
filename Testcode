ll




import java.io.*
import java.nio.file.Files
import java.security.SecureRandom
import javax.crypto.Cipher
import javax.crypto.CipherInputStream
import javax.crypto.spec.GCMParameterSpec
import javax.crypto.spec.SecretKeySpec

// reuse your key and algorithm names
private const val GCM_TAG_LENGTH = 16         // bytes
private const val GCM_NONCE_LENGTH = 12       // bytes
private const val ALGO = "AES/GCM/NoPadding"

// Provide your 16/24/32-byte AES key bytes from where you keep it
private val encryptionKey: ByteArray
    get() = /* TODO: load your key bytes, same key used by encryptString() */

// If a .tar.gz.enc is given, decrypt to a temp .tar.gz and return that file
private fun maybeDecryptToTemp(tarOrEnc: File): File {
    if (!tarOrEnc.name.endsWith(TAR_GZ + ENC)) return tarOrEnc

    val outDir = tarOrEnc.parentFile
    val out = File.createTempFile(tarOrEnc.name.removeSuffix(ENC), null, outDir)
    // ensure .tar.gz suffix on the output
    val normalized = if (out.name.endsWith(TAR_GZ)) out
                     else File(out.parentFile, out.name + TAR_GZ)

    decryptEncFileTo(tarOrEnc, normalized)
    normalized.deleteOnExit()
    return normalized
}

/** Streaming AES-GCM file decryption: [IV(12)][ciphertext||tag(16)] -> plain */
private fun decryptEncFileTo(encFile: File, plainOut: File) {
    FileInputStream(encFile).use { fis ->
        // read IV
        val iv = ByteArray(GCM_NONCE_LENGTH)
        val read = fis.read(iv)
        if (read != iv.size) throw IllegalStateException("Encrypted file missing IV")

        val spec = GCMParameterSpec(GCM_TAG_LENGTH * 8, iv)
        val key = SecretKeySpec(encryptionKey, "AES")
        val cipher = Cipher.getInstance(ALGO).apply { init(Cipher.DECRYPT_MODE, key, spec) }

        // stream the rest through CipherInputStream
        CipherInputStream(fis, cipher).use { cis ->
            FileOutputStream(plainOut).use { fos ->
                val buf = ByteArray(64 * 1024)
                while (true) {
                    val n = cis.read(buf)
                    if (n == -1) break
                    fos.write(buf, 0, n)
                }
                fos.flush()
            }
        }
    }
}







override suspend fun evaluateFirmwareCompatibility(
    activeOsVersion: DynamoYoctoOS,
    releaseManifest: SoftwareReleaseManifest,
): Outcome<DynamoFirmwareCompatibilityStatus> {

    extractionFolder.listFiles()?.forEach { f ->
        // If we see the combined package, weâ€™re done: OS is included.
        if (f.name == dynamoOsTarGzFileName /* e.g., firmware_imx6_dynamo.tar.gz.enc */) {
            return Outcome.Ok(DynamoFirmwareCompatibilityStatus.OSUpdateIncluded)
        }
    }

    // fallback if you still want legacy logic:
    return Outcome.Ok(DynamoFirmwareCompatibilityStatus.OSUpdateNotIncluded)
}



