pp


fun DextractYoctoVersion(targzFile: File): Outcome<String> {
    return when (val hillromVersion = searchTarGzFile(targzFile, "hillrom-version")) {
        is Outcome.Ok -> {
            val lines = hillromVersion.value.decodeToString().split('\n').map { it.trim() }
            var match: String? = null

            lines.forEach { line ->
                if (line.contains("Version:")) {
                    val regex = Regex("\\d+(\\.\\d+)+")
                    match = regex.find(line)?.value
                    return@forEach
                }
            }

            if (match != null) {
                ProLog.i(MODULE_NAME, "${targzFile.name} OS version = $match")
                Outcome.Ok(match!!)
            } else {
                ProLog.e(MODULE_NAME, "Failed to decode OS version.")
                Outcome.Error("Failed to decode OS version.")
            }
        }
        is Outcome.Error -> Outcome.Error(hillromVersion.error as String)
    }
}







private val DosTarGzFileName = "firmware_imx6_d.tar.gz.enc"

override suspend fun evaluateFirmwareCompatibility(
    activeOsVersion: DYoctoOS,
    releaseManifest: SoftwareReleaseManifest,
): Outcome<DFirmwareCompatibilityStatus> {

    var containsOS = false
    var ospkgFound = false
    var pkgOsVersion = DYoctoOS.INVALID

    var shouldSendOsUpdate = false
    var appTarFound = false
    var error: DFirmwareCompatibilityStatus? = null

    // 1) OS tar check (only if ospkgTarGzFileName exists)
    extractionFolder.listFiles()?.forEach { file ->
        if (file.name == ospkgTarGzFileName) {
            ospkgFound = true

            when (val ver = DextractYoctoVersion(file)) {
                is Outcome.Ok -> {
                    val pkgOs: SemVer? = SemVer.fromString(ver.value)
                    val deviceOs: SemVer? = SemVer.fromString(d.getOperatingSystemVersion().trim())

                    shouldSendOsUpdate = (pkgOs != null && deviceOs != null && pkgOs != deviceOs)

                    if (pkgOs != null) {
                        containsOS = shouldContainOS(pkgOs)
                        pkgOsVersion = DYoctoOS.fromVersion(pkgOs)
                    }
                }

                is Outcome.Error -> {
                    ProLog.e(
                        MODULE_NAME,
                        "Could not find yocto version in ${file.name}. Result: ${ver.error as String}"
                    )
                    error = DFirmwareCompatibilityStatus.Error
                }
            }

            return@forEach
        }
    }

    // 2) dAppTar verification
    extractionFolder.listFiles()?.forEach { file ->
        if (file.name == dAppTar) {
            appTarFound = true

            if (pkgOsVersion == DYoctoOS.INVALID) {
                pkgOsVersion = DYoctoOS.DUNFELL
            }

            return@forEach
        }
    }

    // ONE FINAL RETURN
    val result =
        when {
            error != null ->
                Outcome.Error(error!!)

            !appTarFound -> {
                ProLog.e(MODULE_NAME, "dAppTar not found in extraction folder: $dAppTar")
                Outcome.Error(DFirmwareCompatibilityStatus.Error)
            }

            shouldSendOsUpdate ->
                Outcome.Ok(DFirmwareCompatibilityStatus.OSUpdateIncluded)

            else ->
                Outcome.Ok(DFirmwareCompatibilityStatus.OSUpdateNotIncluded)
        }

    return result
}




