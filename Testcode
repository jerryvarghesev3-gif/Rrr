void Firmware::updateBoard(quint32 destination, MEM_MEMORY_TYPE memoryType, QString binPath)
{
    updateComplete[destination]   = false;
    updateSuccessful[destination] = false;

    QString board = boardsList[destination];

    // ✅ TYPES MUST BE CORRECT (this fixes your GN2_Address / QString compile error)
    GN2_Address addressForUpdate = GN2A_MCB;                 // enum
    QString     serverBoard     = boardsList[addressForUpdate]; // QString (NOT GN2_Address)

    RPCA_Plant* rp = RPCA_Plant::getInstance();

    // keep your existing special case (ATLAS via ATLAS address if not connected to MCB)
    if ((!rp->isConnectedTo(GN2A_MCB)) && (destination == GN2A_ATLAS))
    {
        addressForUpdate = GN2A_ATLAS;
    }

    // ✅ serverBoard must be derived from addressForUpdate (QString)
    serverBoard = boardsList[addressForUpdate];

    ProLog().i(MODULE_NAME, QString("Firmware upgrade started on %1").arg(board).toStdString());

    // ------------------------------------------------------------------------------------
    // Decide image path + toggleBank (KEEP YOUR EXISTING WORKFLOW)
    // ------------------------------------------------------------------------------------
    bool toggleBankOnCurrentBoard = false;

    QString somFileName = "N/A";

    // you already have this list somewhere in your code (from your screenshots)
    // QList<QString> binariesFound;  <-- assumed existing

    if (MEM_MEMORY_TYPE_INTERNAL_FLASH == memoryType)
    {
        if (GN2A_SOM == destination)
        {
            // find SOM tar (your existing logic)
            QRegularExpression tarRx("dynamoSOMApp*\\.tar\\.gz\\.enc");
            int32_t indexOfTarBinary = binariesFound.indexOf(tarRx);

            if (indexOfTarBinary > -1)
            {
                somFileName = binariesFound.at(indexOfTarBinary);
                binPath.append("/");
                binPath.append(somFileName);
            }
            else
            {
                // fallback to existing internal mapping if your old code did that
                binPath.append("/");
                binPath.append(internalBinaries[destination]);
            }
        }
        else
        {
            binPath.append("/");
            binPath.append(internalBinaries[destination]);
        }

        // Do not toggle the banks if internal memory.
        toggleBankOnCurrentBoard = false;
    }
    else if (MEM_MEMORY_TYPE_EXTERNAL_FLASH0 == memoryType)
    {
        toggleBankOnCurrentBoard = false;
        binPath.append("/");
        binPath.append(externalImages[destination]);
    }

    ProLog().i(MODULE_NAME, QString("Image path: %1").arg(binPath).toStdString());

    // ------------------------------------------------------------------------------------
    // ✅ MINIMAL FIX: SOM decrypt-first, then SOM tar upload (NO "finish" on decrypt)
    // ------------------------------------------------------------------------------------

    // Detect decrypt file name (this variable should come from your existing logic)
    // Example: QString decryptFileName;  <-- you already have it in your code
    // Example: decrypt is inside extracted folder / same folder where tar is found
    // Make sure decryptFileName is filled like "decrypt" or "decrypt.part" based on your packaging
    QString decryptFileName = "decrypt"; // <-- REPLACE this with your real variable if you already have it

    // build decryptPath using the same parent folder as tar/binPath
    QString decryptPath;
    {
        // parent folder of binPath
        QFileInfo fi(binPath);
        decryptPath = fi.absolutePath() + "/" + decryptFileName;
    }

    auto startSomTarUpload = [&]()
    {
        FirmwareUpdateCAN* fw = new FirmwareUpdateCAN();
        fw->setImageData(binPath);
        fw->onChangedSelectedServer(addressForUpdate, serverBoard, NULL);
        fw->setDestination(destination);

        // SOM extra file-info message (your existing block)
        if (GN2A_SOM == destination)
        {
            MEM_SendImageFileNameRequest  req = MEM_SendImageFileNameRequest_init_zero;
            MEM_SendImageFileNameResponse rsp = MEM_SendImageFileNameResponse_init_zero;
            req.memoryType = memoryType;

            // ✅ SAFE copy from QString -> req.imageName (fixes crashes)
            const QByteArray nameBytes = somFileName.toUtf8();
            memset(req.imageName, 0, sizeof(req.imageName));
            const size_t copyLen = std::min((size_t)sizeof(req.imageName) - 1, (size_t)nameBytes.size());
            memcpy(req.imageName, nameBytes.constData(), copyLen);

            ProLog().i(MODULE_NAME,
                       QString("Downloading %1 to SOM").arg(QString::fromUtf8(req.imageName)).toStdString());

            if (CMD_OK != MEM_SendImageFileName(GN2A_SOM, &req, &rsp))
            {
                ProLog().w(MODULE_NAME, QString("Could not send file info to %1").arg(board).toStdString());
                onBoardUpgraded(fw, destination, false);
                return;
            }
        }

        // validate image (keep your original flag)
        if (!fw->validateImage(memoryType, false)) // do not check board version
        {
            ProLog().w(MODULE_NAME, QString("Image Verification failed on %1").arg(board).toStdString());
            onBoardUpgraded(fw, destination, false);
            return;
        }

        // ✅ IMPORTANT: connect with correct signal signatures (from your header screenshot)
        connect(fw, &FirmwareUpdateCAN::imageUploadCompleted,
                this, &Firmware::onBoardUpgraded, Qt::QueuedConnection);

        connect(fw, &FirmwareUpdateCAN::errorNotification,
                this, &Firmware::onObservedError, Qt::QueuedConnection);

        connect(fw, &FirmwareUpdateCAN::infoNotification,
                this, &Firmware::onObservedInfo, Qt::QueuedConnection);

        connect(fw, &FirmwareUpdateCAN::progressObserved,
                this, &Firmware::onObservedProgress, Qt::QueuedConnection);

        connect(fw, &FirmwareUpdateCAN::newProgressPhaseStarted,
                this, &Firmware::onPhaseChanged, Qt::QueuedConnection);

        connect(this, &Firmware::abortUpgrade,
                fw, &FirmwareUpdateCAN::abortUpgrade, Qt::DirectConnection);

        currentMemoryType = memoryType;
        fw->startUpdate(memoryType, toggleBankOnCurrentBoard);
    };

    // ✅ ONLY SOM needs decrypt special handling
    if (destination == GN2A_SOM && !decryptFileName.isEmpty())
    {
        ProLog().i(MODULE_NAME, "Uploading decrypt to SOM (first)");

        FirmwareUpdateCAN* fwDecrypt = new FirmwareUpdateCAN();
        fwDecrypt->setImageData(decryptPath);
        fwDecrypt->onChangedSelectedServer(addressForUpdate, serverBoard, NULL);
        fwDecrypt->setDestination(destination);

        // ✅ DO NOT call onBoardUpgraded(success) for decrypt
        connect(fwDecrypt, &FirmwareUpdateCAN::imageUploadCompleted,
                this,
                [=](FirmwareUpdateCAN* /*fw*/, quint32 /*board*/, bool ok1)
                {
                    if (!ok1)
                    {
                        ProLog().w(MODULE_NAME, "Decrypt upload failed");
                        onBoardUpgraded(fwDecrypt, destination, false);
                        return;
                    }

                    ProLog().i(MODULE_NAME, "Decrypt upload success. Uploading dynamoSOMApp tar (second)");
                    startSomTarUpload();
                },
                Qt::QueuedConnection);

        // optional: keep your progress/error prints for decrypt too
        connect(fwDecrypt, &FirmwareUpdateCAN::errorNotification,
                this, &Firmware::onObservedError, Qt::QueuedConnection);
        connect(fwDecrypt, &FirmwareUpdateCAN::infoNotification,
                this, &Firmware::onObservedInfo, Qt::QueuedConnection);
        connect(fwDecrypt, &FirmwareUpdateCAN::progressObserved,
                this, &Firmware::onObservedProgress, Qt::QueuedConnection);
        connect(fwDecrypt, &FirmwareUpdateCAN::newProgressPhaseStarted,
                this, &Firmware::onPhaseChanged, Qt::QueuedConnection);
        connect(this, &Firmware::abortUpgrade,
                fwDecrypt, &FirmwareUpdateCAN::abortUpgrade, Qt::DirectConnection);

        currentMemoryType = memoryType;
        fwDecrypt->startUpdate(memoryType, false);

        return; // ✅ stop here; tar upload starts from callback
    }

    // Non-SOM OR no decrypt => run old behavior
    startSomTarUpload();
}
