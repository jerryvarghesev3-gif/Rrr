if (MEM_MEMORY_TYPE_INTERNAL_FLASH == memoryType)
{
    if (GN2A_SOM == destination)
    {
        // Keep binPath as folder
        const QString baseDir = binPath;

        // Find SOM tar
        QRegularExpression tarRx("^dynamoSOMApp.*\\.tar\\.gz\\.enc$");
        int indexOfTarBinary = binariesFound.indexOf(tarRx);
        if (indexOfTarBinary < 0)
        {
            ProLog().w(MODULE_NAME, ("SOM tar not found in folder: " + baseDir).toStdString());
            onBoardUpgraded(nullptr, destination, false);
            return;
        }

        const QString tarName = binariesFound.at(indexOfTarBinary);
        const QString tarPath = baseDir + "/" + tarName;

        // Find decrypt (optional)
        QRegularExpression decryptRx("^decrypt(\\..+)?$");
        int indexOfDecrypt = binariesFound.indexOf(decryptRx);

        QString decryptName;
        QString decryptPath;
        if (indexOfDecrypt > -1)
        {
            decryptName = binariesFound.at(indexOfDecrypt);
            decryptPath = baseDir + "/" + decryptName;
        }

        // Freeze these so async code never sees changed values
        const quint32 dest = destination;
        const quint32 addr = addressForUpdate;
        const QString srv  = serverBoard;
        const MEM_MEMORY_TYPE memType = memoryType;

        // Helper: send file info to SOM
        auto sendFileInfoToSom = [&](const QString& fileName) -> bool {
            MEM_SendImageFileNameRequest req = MEM_SendImageFileNameRequest_init_zero;
            MEM_SendImageFileNameResponse rsp = MEM_SendImageFileNameResponse_init_zero;
            req.memoryType = memType;

            const QByteArray nameBytes = fileName.toUtf8();
            memset(req.imageName, 0, sizeof(req.imageName));
            const int copyLen = qMin((int)sizeof(req.imageName) - 1, nameBytes.size());
            memcpy(req.imageName, nameBytes.constData(), copyLen);

            return (CMD_OK == MEM_SendImageFileName(GN2A_SOM, &req, &rsp));
        };

        // Create ONE uploader object and set server ONCE (this avoids "Server=INVALID" on second file)
        FirmwareUpdateCAN* fw = new FirmwareUpdateCAN();
        fw->onChangedSelectedServer(addr, srv, NULL);
        fw->setDestination(dest);

        // Normal connects (same as your existing ones)
        connect(fw, &FirmwareUpdateCAN::errorNotification, this, &Firmware::onObservedError);
        connect(fw, &FirmwareUpdateCAN::infoNotification, this, &Firmware::onObservedInfo);
        connect(fw, &FirmwareUpdateCAN::progressObserved, this, &Firmware::onObservedProgress);
        connect(fw, &FirmwareUpdateCAN::newProgressPhaseStarted, this, &Firmware::onPhaseChanged);

        // Phase handler: after decrypt completes -> upload tar
        bool decryptDone = decryptName.isEmpty();   // if no decrypt, tar is first/only
        bool tarDone = false;

        connect(fw, &FirmwareUpdateCAN::imageUploadCompleted, this,
            [=, &decryptDone, &tarDone](FirmwareUpdateCAN* /*fwSig*/, quint32 /*board*/, bool ok) mutable
            {
                if (!ok)
                {
                    onBoardUpgraded(fw, dest, false);
                    return;
                }

                // If decrypt just finished, now start TAR
                if (!decryptDone)
                {
                    decryptDone = true;

                    // Small delay helps avoid writer/connection teardown race
                    QTimer::singleShot(300, this, [=, &tarDone]() mutable {
                        ProLog().i(MODULE_NAME, ("Uploading " + tarName + " to SOM (second)").toStdString());

                        fw->setImageData(tarPath);

                        if (!sendFileInfoToSom(tarName))
                        {
                            ProLog().w(MODULE_NAME, ("Could not send file info for " + tarName).toStdString());
                            onBoardUpgraded(fw, dest, false);
                            return;
                        }

                        currentMemoryType = memType;
                        fw->startUpdate(memType, false);
                    });

                    return;
                }

                // If we reach here, TAR finished successfully
                if (!tarDone)
                {
                    tarDone = true;
                    onBoardUpgraded(fw, dest, true);
                }
            },
            Qt::QueuedConnection);

        // ---- Start upload sequence ----
        if (!decryptName.isEmpty())
        {
            ProLog().i(MODULE_NAME, ("Uploading " + decryptName + " to SOM (first)").toStdString());

            fw->setImageData(decryptPath);

            if (!sendFileInfoToSom(decryptName))
            {
                ProLog().w(MODULE_NAME, ("Could not send file info for " + decryptName).toStdString());
                onBoardUpgraded(fw, dest, false);
                return;
            }

            currentMemoryType = memType;
            fw->startUpdate(memType, false);
            return;
        }

        // No decrypt -> upload TAR directly
        ProLog().i(MODULE_NAME, ("Uploading " + tarName + " to SOM (only)").toStdString());

        fw->setImageData(tarPath);

        if (!sendFileInfoToSom(tarName))
        {
            ProLog().w(MODULE_NAME, ("Could not send file info for " + tarName).toStdString());
            onBoardUpgraded(fw, dest, false);
            return;
        }

        currentMemoryType = memType;
        fw->startUpdate(memType, false);
        return;
    }

    // ---- everything below remains yours (other boards unchanged) ----
}
