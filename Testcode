if (MEM_MEMORY_TYPE_INTERNAL_FLASH == memoryType)
{
    if (GN2A_SOM == destination)
    {
        // IMPORTANT: binPath is a folder path. Do not append filenames into binPath permanently.
        const QString baseDir = binPath;

        // binariesFound should already contain the filenames in baseDir
        // (whatever your existing code does to fill binariesFound - keep it)

        // 1) Find decrypt (optional)
        QRegularExpression decryptRx("^decrypt(\\..+)?$");
        const int indexOfDecrypt = binariesFound.indexOf(decryptRx);

        QString decryptFileName;
        QString decryptPath;
        if (indexOfDecrypt >= 0)
        {
            decryptFileName = binariesFound.at(indexOfDecrypt);
            decryptPath = baseDir + "/" + decryptFileName;
        }

        // 2) Find SOM tar (required)
        QRegularExpression tarRx("^dynamoSOMApp.*\\.tar\\.gz\\.enc$");
        const int indexOfTarBinary = binariesFound.indexOf(tarRx);

        if (indexOfTarBinary < 0)
        {
            ProLog().w(MODULE_NAME,
                       QString("SOM tar not found in folder: %1").arg(baseDir).toStdString());
            onBoardUpgraded(nullptr, destination, false);
            return;
        }

        const QString somFileName = binariesFound.at(indexOfTarBinary);
        const QString somTarPath  = baseDir + "/" + somFileName;

        // Helper to start an upload (keeps your existing MEM_SendImageFileName usage)
        auto startUpload = [&](const QString& fileName,
                               const QString& filePath,
                               std::function<void()> onSuccessStartNext)
        {
            FirmwareUpdateCAN* fw = new FirmwareUpdateCAN();
            fw->setImageData(filePath);
            fw->onChangedSelectedServer(addressForUpdate, serverBoard, NULL);
            fw->setDestination(destination);

            MEM_SendImageFileNameRequest req = MEM_SendImageFileNameRequest_init_zero;
            MEM_SendImageFileNameResponse rsp = MEM_SendImageFileNameResponse_init_zero;
            req.memoryType = memoryType;

            // include null-terminator safely
            const QByteArray nameBytes = fileName.toUtf8();
            memset(req.imageName, 0, sizeof(req.imageName));
            memcpy(req.imageName, nameBytes.constData(),
                   std::min((int)sizeof(req.imageName) - 1, nameBytes.size()));

            ProLog().i(MODULE_NAME,
                       QString("Downloading %1 to SOM (path=%2)")
                           .arg(fileName, filePath).toStdString());

            if (CMD_OK != MEM_SendImageFileName(GN2A_SOM, &req, &rsp))
            {
                ProLog().w(MODULE_NAME,
                           QString("Could not send file info for %1").arg(fileName).toStdString());
                onBoardUpgraded(fw, destination, false);
                return;
            }

            // ✅ IMPORTANT: imageUploadCompleted has NO args in your build, so lambda must take none.
            if (onSuccessStartNext)
            {
                connect(fw, &FirmwareUpdateCAN::imageUploadCompleted, this, [=]() {
                    onSuccessStartNext();
                }, Qt::QueuedConnection);
            }

            // Keep your existing wiring for progress/error -> your UI + state machine
            connect(fw, &FirmwareUpdateCAN::errorNotification, this, &Firmware::onBoardUpgraded);
            connect(fw, &FirmwareUpdateCAN::infoNotification,  this, &Firmware::onObservedInfo);
            connect(fw, &FirmwareUpdateCAN::progressObserved,  this, &Firmware::onObservedProgress);
            connect(fw, &FirmwareUpdateCAN::newProgressPhaseStarted, this, &Firmware::onPhaseChanged);

            // When final file (tar) completes, your existing flow should continue.
            // If you already rely on imageUploadCompleted -> onBoardUpgraded somewhere, keep it ONLY for tar.
            // We do NOT connect imageUploadCompleted to onBoardUpgraded for decrypt, to avoid “finishing early”.
            //
            // Start transfer
            currentMemoryType = memoryType;
            fw->startUpdate(memoryType, false);
        };

        // ✅ Correct order:
        //    1) decrypt first (if present)
        //    2) tar second (always)
        if (!decryptFileName.isEmpty())
        {
            startUpload(decryptFileName, decryptPath, [=]() {
                // After decrypt upload success, start tar upload
                startUpload(somFileName, somTarPath, nullptr);
            });
        }
        else
        {
            // No decrypt => normal old behavior: upload tar
            startUpload(somFileName, somTarPath, nullptr);
        }

        return;
    }

    // ✅ EVERYTHING BELOW REMAINS YOUR EXISTING CODE (other internal-flash boards)
    // (do not modify)
}






const QByteArray nameBytes = fileName.toUtf8();
const int maxCopy = static_cast<int>(sizeof(req.imageName)) - 1;
const int copyLen = (nameBytes.size() < maxCopy) ? nameBytes.size() : maxCopy;

memset(req.imageName, 0, sizeof(req.imageName));
memcpy(req.imageName, nameBytes.constData(), copyLen);
