package com.connect.connection

import android.Manifest
import android.content.Intent
import android.content.pm.PackageManager
import android.os.Bundle
import android.view.Surface
import android.widget.Button
import android.widget.TextView
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import androidx.camera.core.*
import androidx.camera.lifecycle.ProcessCameraProvider
import androidx.camera.view.PreviewView
import androidx.core.content.ContextCompat
import com.google.mlkit.vision.barcode.BarcodeScanning
import com.google.mlkit.vision.barcode.common.Barcode
import com.google.mlkit.vision.common.InputImage
import java.util.concurrent.Executors
import java.util.concurrent.atomic.AtomicBoolean

class QRBActivity : AppCompatActivity() {

    // --- UI ---
    private lateinit var previewView: PreviewView
    private lateinit var txtScanValue: TextView
    private lateinit var btnRescan: Button
    private lateinit var btnContinue: Button
    private lateinit var btnCancel: Button

    // --- camera / scan ---
    private val cameraExecutor = Executors.newSingleThreadExecutor()
    private val analyzing = AtomicBoolean(false)
    private var lastDecoded: String? = null

    // values we receive from A/SummaryA
    private var gatewayId: String = ""
    private var bedId: String = ""
    private var imageUriStrFromA: String? = null

    companion object {
        const val EXTRA_GATEWAY   = "gatewayId"
        const val EXTRA_BED       = "bedId"
        const val EXTRA_IMAGE_URI = "imageUri"
        const val EXTRA_LOCATION  = "locationId"
    }

    // permission launcher
    private val requestCameraPerm =
        registerForActivityResult(androidx.activity.result.contract.ActivityResultContracts.RequestPermission()) { granted ->
            if (granted) startCamera() else finish()
        }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_qrb) // make sure ids match below

        // read values from previous page
        gatewayId   = intent.getStringExtra(EXTRA_GATEWAY).orEmpty()
        bedId       = intent.getStringExtra(EXTRA_BED).orEmpty()
        imageUriStrFromA = intent.getStringExtra(EXTRA_IMAGE_URI)

        // bind views
        previewView   = findViewById(R.id.previewView)
        txtScanValue  = findViewById(R.id.txtScanValue)
        btnRescan     = findViewById(R.id.btnRescan)
        btnContinue   = findViewById(R.id.btnContinue)
        btnCancel     = findViewById(R.id.btnCancel)

        txtScanValue.text = "Aim at Location QR"
        btnContinue.isEnabled = false

        btnRescan.setOnClickListener {
            lastDecoded = null
            txtScanValue.text = ""
            analyzing.set(true)
            btnContinue.isEnabled = false
        }

        btnCancel.setOnClickListener { finish() }

        btnContinue.setOnClickListener {
            val loc = lastDecoded?.trim().orEmpty()
            if (loc.isEmpty()) {
                Toast.makeText(this, "Scan a Location QR first", Toast.LENGTH_SHORT).show()
                return@setOnClickListener
            }
            // move to SummaryBActivity with gateway/bed/location (+ image from A if present)
            val i = Intent(this, SummaryBActivity::class.java).apply {
                putExtra(EXTRA_GATEWAY, gatewayId)
                putExtra(EXTRA_BED, bedId)
                putExtra(EXTRA_LOCATION, loc)
                imageUriStrFromA?.let { putExtra(EXTRA_IMAGE_URI, it) }
            }
            startActivity(i)
            finish()
        }

        // camera permission + start
        if (ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA)
            == PackageManager.PERMISSION_GRANTED
        ) startCamera() else requestCameraPerm.launch(Manifest.permission.CAMERA)
    }

    override fun onDestroy() {
        super.onDestroy()
        try { cameraExecutor.shutdown() } catch (_: Exception) {}
    }

    // --- camera setup (QR only) ---
    @androidx.annotation.OptIn(ExperimentalGetImage::class)
    private fun startCamera() {
        val cameraProviderFuture = ProcessCameraProvider.getInstance(this)
        cameraProviderFuture.addListener({
            val cameraProvider = cameraProviderFuture.get()

            val preview = Preview.Builder()
                .setTargetRotation(previewView.display?.rotation ?: Surface.ROTATION_0)
                .build().also { it.setSurfaceProvider(previewView.surfaceProvider) }

            val analysis = ImageAnalysis.Builder()
                .setBackpressureStrategy(ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)
                .setTargetRotation(previewView.display?.rotation ?: Surface.ROTATION_0)
                .build()

            val scanner = BarcodeScanning.getClient(
                com.google.mlkit.vision.barcode.BarcodeScannerOptions.Builder()
                    .setBarcodeFormats(Barcode.FORMAT_QR_CODE)
                    .build()
            )

            analysis.setAnalyzer(cameraExecutor) { imageProxy ->
                try {
                    val media = imageProxy.image ?: run { imageProxy.close(); return@setAnalyzer }
                    if (!analyzing.get()) { imageProxy.close(); return@setAnalyzer }

                    val input = InputImage.fromMediaImage(
                        media,
                        imageProxy.imageInfo.rotationDegrees
                    )
                    scanner.process(input)
                        .addOnSuccessListener { codes ->
                            val v = codes.firstOrNull()?.rawValue
                            if (!v.isNullOrBlank()) {
                                lastDecoded = v.trim()
                                runOnUiThread {
                                    txtScanValue.text = lastDecoded
                                    btnContinue.isEnabled = true
                                }
                                // pause analyzer until user hits RESCAN
                                analyzing.set(false)
                            }
                        }
                        .addOnCompleteListener { imageProxy.close() }
                } catch (_: Throwable) {
                    imageProxy.close()
                }
            }

            val selector = CameraSelector.DEFAULT_BACK_CAMERA
            cameraProvider.unbindAll()
            cameraProvider.bindToLifecycle(this, selector, preview, analysis)

            // ready to scan
            analyzing.set(true)
        }, ContextCompat.getMainExecutor(this))
    }
}




package com.connect.connection

import android.content.Intent
import android.net.Uri
import android.os.Bundle
import android.widget.Button
import android.widget.ImageView
import android.widget.TextView
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import androidx.core.net.toUri
import org.eclipse.paho.client.mqttv3.IMqttActionListener
import org.eclipse.paho.client.mqttv3.MqttCallbackExtended
import org.eclipse.paho.client.mqttv3.MqttMessage
import org.json.JSONObject

class SummaryBActivity : AppCompatActivity() {

    private lateinit var txtGateway: TextView
    private lateinit var txtBed: TextView
    private lateinit var txtLocation: TextView
    private lateinit var txtInfo: TextView
    private lateinit var imgPreview: ImageView
    private lateinit var btnBack: Button
    private lateinit var btnNext: Button

    private var gatewayId = ""
    private var bedId = ""
    private var locationId = ""
    private var imageUri: Uri? = null

    companion object {
        const val EXTRA_GATEWAY   = "gatewayId"
        const val EXTRA_BED       = "bedId"
        const val EXTRA_IMAGE_URI = "imageUri"
        const val EXTRA_LOCATION  = "locationId"
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_summary_b)

        // bind
        txtGateway  = findViewById(R.id.txtGatewayB)
        txtBed      = findViewById(R.id.txtBedB)
        txtLocation = findViewById(R.id.txtLocationB)
        txtInfo     = findViewById(R.id.txtInfoB)
        imgPreview  = findViewById(R.id.imgPreviewB)
        btnBack     = findViewById(R.id.btnBackB)
        btnNext     = findViewById(R.id.btnNextB)

        // extras
        gatewayId  = intent.getStringExtra(EXTRA_GATEWAY).orEmpty()
        bedId      = intent.getStringExtra(EXTRA_BED).orEmpty()
        locationId = intent.getStringExtra(EXTRA_LOCATION).orEmpty()
        intent.getStringExtra(EXTRA_IMAGE_URI)?.let { imageUri = it.toUri() }

        // show
        txtGateway.text = "Gateway: $gatewayId"
        txtBed.text     = "Bed ID: $bedId"
        txtLocation.text= "Location ID: $locationId"
        imageUri?.let { imgPreview.setImageURI(it) }

        btnBack.setOnClickListener { finish() }

        btnNext.setOnClickListener {
            if (gatewayId.isEmpty() || bedId.isEmpty() || locationId.isEmpty()) {
                Toast.makeText(this, "Missing IDs", Toast.LENGTH_SHORT).show()
                return@setOnClickListener
            }
            txtInfo.text = "Setting location..."
            btnNext.isEnabled = false
            performSetLocation()
        }
    }

    /**
     * Performs the old “set_location” request over MQTT and waits for the reply.
     * This mirrors your previous working logic: publish to request topic and
     * listen on response topic keyed by bedId.
     *
     * Assumes you have:
     *   - MqttHolder.client (already connected)
     *   - topicSetLocationReq(gatewayId: String): String
     *   - topicSetLocationResp(bedId: String): String
     */
    private fun performSetLocation() {
        val c = MqttHolder.client ?: run {
            txtInfo.text = "MQTT not connected"
            btnNext.isEnabled = true
            return
        }

        // Subscribe to response first
        val respTopic = topicSetLocationResp(bedId)
        c.subscribe(respTopic, 1, null, object : IMqttActionListener {
            override fun onSuccess(asyncActionToken: org.eclipse.paho.client.mqttv3.IMqttToken?) {
                // After subscribe, publish request
                publishSetLocation()
            }
            override fun onFailure(
                asyncActionToken: org.eclipse.paho.client.mqttv3.IMqttToken?,
                exception: Throwable?
            ) {
                txtInfo.text = "Subscribe failed: ${exception?.message}"
                btnNext.isEnabled = true
            }
        })

        // Callback to capture response
        c.setCallback(object : MqttCallbackExtended {
            override fun connectionLost(cause: Throwable?) {}
            override fun messageArrived(topic: String?, message: MqttMessage?) {
                if (topic == respTopic) {
                    val payload = message?.toString().orEmpty()
                    runOnUiThread { handleSetLocationResponse(payload) }
                }
            }
            override fun deliveryComplete(token: org.eclipse.paho.client.mqttv3.IMqttDeliveryToken?) {}
            override fun connectComplete(reconnect: Boolean, serverURI: String?) {}
        })
    }

    private fun publishSetLocation(force: Boolean = false) {
        val c = MqttHolder.client ?: return
        val reqTopic = topicSetLocationReq(gatewayId)

        val data = JSONObject().apply {
            put("bedId", bedId)
            put("locationId", locationId)
            put("force", force)
        }
        val req = JSONObject().apply {
            put("command", "set_location")
            put("data", data)
        }
        val payload = req.toString().toByteArray(Charsets.UTF_8)

        c.publish(reqTopic, payload, 1, false, null, object : IMqttActionListener {
            override fun onSuccess(asyncActionToken: org.eclipse.paho.client.mqttv3.IMqttToken?) {
                // waiting on response now…
            }
            override fun onFailure(
                asyncActionToken: org.eclipse.paho.client.mqttv3.IMqttToken?,
                exception: Throwable?
            ) {
                runOnUiThread {
                    txtInfo.text = "Publish failed: ${exception?.message}"
                    btnNext.isEnabled = true
                }
            }
        })
    }

    // Parse reply JSON and navigate to the final SummaryActivity
    private fun handleSetLocationResponse(json: String) {
        try {
            val root = JSONObject(json)
            val status = root.optInt("status", -1)

            // Some servers return the location back in data; keep the original if not present.
            val loc = root.optJSONObject("data")
                ?.optString("locationId")
                ?.takeIf { it.isNotBlank() }
                ?: locationId

            val i = Intent(this, SummaryActivity::class.java).apply {
                putExtra("gatewayId", gatewayId)
                putExtra("bedId", bedId)
                putExtra("locationId", loc)
                putExtra("status", status)
            }
            startActivity(i)
            finish()
        } catch (t: Throwable) {
            txtInfo.text = "Response parse error: ${t.message}"
            btnNext.isEnabled = true
        }
    }

    // ---------- topic helpers (match your old names) ----------
    private fun topicSetLocationReq(gw: String) = "gw/$gw/req/set_location"
    private fun topicSetLocationResp(bed: String) = "bed/$bed/resp/set_location"
}




package com.connect.connection

import android.content.Intent
import android.os.Bundle
import android.widget.Button
import android.widget.TextView
import androidx.appcompat.app.AppCompatActivity

class SummaryActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_summary)

        val status     = intent.getIntExtra("status", -1)
        val gatewayId  = intent.getStringExtra("gatewayId") ?: ""
        val bedId      = intent.getStringExtra("bedId") ?: ""
        val locationId = intent.getStringExtra("locationId") ?: ""

        val txt = findViewById<TextView>(R.id.summaryText)
        txt.text = buildString {
            appendLine(if (status == 0) "✅  Location set OK" else "❌  set_location failed (status=$status)")
            appendLine("Gateway: $gatewayId")
            appendLine("Bed ID: $bedId")
            appendLine("Location ID: $locationId")
        }

        findViewById<Button>(R.id.btnDone).setOnClickListener {
            val i = Intent(this, MainActivity::class.java).apply {
                addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP or Intent.FLAG_ACTIVITY_SINGLE_TOP)
            }
            startActivity(i)
            finish()
        }
    }
}

