<?xml version="1.0" encoding="utf-8"?>
<!-- Simple overlay: full-screen camera preview + bottom hint text -->
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/root"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="#000">

    <!-- CameraX preview -->
    <androidx.camera.view.PreviewView
        android:id="@+id/previewViewB"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />

    <!-- Bottom hint (like your AActivity) -->
    <TextView
        android:id="@+id/txtScanValueB"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_gravity="bottom"
        android:padding="12dp"
        android:text="Scan a Location QR..."
        android:textColor="#FFFFFF"
        android:textSize="16sp"
        android:background="#66000000" />
</FrameLayout>









package com.connect.connection

import android.Manifest
import android.content.ContentValues
import android.content.Intent
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.provider.MediaStore
import android.util.Log
import android.view.Surface
import android.widget.TextView
import android.widget.Toast
import androidx.activity.result.contract.ActivityResultContracts
import androidx.annotation.OptIn
import androidx.appcompat.app.AppCompatActivity
import androidx.camera.core.*
import androidx.camera.lifecycle.ProcessCameraProvider
import androidx.camera.view.PreviewView
import androidx.core.content.ContextCompat
import com.google.mlkit.vision.barcode.Barcode
import com.google.mlkit.vision.barcode.BarcodeScannerOptions
import com.google.mlkit.vision.barcode.BarcodeScanning
import com.google.mlkit.vision.common.InputImage
import java.text.SimpleDateFormat
import java.util.Locale
import java.util.concurrent.ExecutorService
import java.util.concurrent.Executors
import java.util.concurrent.atomic.AtomicBoolean

class QRBActivity : AppCompatActivity() {

    companion object {
        const val EXTRA_GATEWAY   = "gatewayId"
        const val EXTRA_BED       = "bedId"
        const val EXTRA_LOCATION  = "locationId"
        const val EXTRA_IMAGE_URI = "imageUri"
        private const val TAG = "QRB"
    }

    // UI
    private lateinit var previewViewB: PreviewView
    private lateinit var txtScanValueB: TextView

    // Camera
    private lateinit var cameraExecutor: ExecutorService
    private var imageAnalysis: ImageAnalysis? = null
    private var imageCapture: ImageCapture? = null
    private val analyzing = AtomicBoolean(false)

    // Inputs from previous screen
    private var gatewayId: String = ""
    private var bedId: String = ""

    // Values we produce
    private var locationId: String = ""
    private var lastDecoded: String? = null

    // ML Kit
    private val barcodeOptions = BarcodeScannerOptions.Builder()
        .setBarcodeFormats(Barcode.FORMAT_QR_CODE)
        .build()
    private val barcodeScanner by lazy { BarcodeScanning.getClient(barcodeOptions) }

    // permission
    private val requestCameraPerm =
        registerForActivityResult(ActivityResultContracts.RequestPermission()) { granted ->
            if (granted) startCamera() else {
                Toast.makeText(this, "Camera permission required", Toast.LENGTH_LONG).show()
                finish()
            }
        }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_qrb)

        // bind
        previewViewB   = findViewById(R.id.previewViewB)
        txtScanValueB  = findViewById(R.id.txtScanValueB)

        // extras from A / Main
        gatewayId = intent.getStringExtra(EXTRA_GATEWAY).orEmpty()
        bedId     = intent.getStringExtra(EXTRA_BED).orEmpty()

        cameraExecutor = Executors.newSingleThreadExecutor()

        // permission + start
        if (ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA)
            == android.content.pm.PackageManager.PERMISSION_GRANTED) {
            startCamera()
        } else {
            requestCameraPerm.launch(Manifest.permission.CAMERA)
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        try {
            imageAnalysis?.clearAnalyzer()
            cameraExecutor.shutdown()
        } catch (_: Exception) { }
    }

    // ---------------- Camera + Analyzer ----------------

    @OptIn(ExperimentalGetImage::class)
    private fun startCamera() {
        val cameraProviderFuture = ProcessCameraProvider.getInstance(this)
        cameraProviderFuture.addListener({
            val provider = cameraProviderFuture.get()

            val preview = Preview.Builder()
                .setTargetRotation(previewViewB.display?.rotation ?: Surface.ROTATION_0)
                .build().also {
                    it.setSurfaceProvider(previewViewB.surfaceProvider)
                }

            imageCapture = ImageCapture.Builder()
                .setTargetRotation(previewViewB.display?.rotation ?: Surface.ROTATION_0)
                .setCaptureMode(ImageCapture.CAPTURE_MODE_MINIMIZE_LATENCY)
                .build()

            imageAnalysis = ImageAnalysis.Builder()
                .setTargetRotation(previewViewB.display?.rotation ?: Surface.ROTATION_0)
                .setBackpressureStrategy(ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)
                .build().also { proxy ->
                    proxy.setAnalyzer(cameraExecutor) { imageProxy ->
                        try {
                            val media = imageProxy.image ?: run {
                                imageProxy.close(); return@setAnalyzer
                            }
                            if (analyzing.getAndSet(true)) {
                                imageProxy.close(); return@setAnalyzer
                            }

                            val input = InputImage.fromMediaImage(
                                media,
                                imageProxy.imageInfo.rotationDegrees
                            )

                            barcodeScanner.process(input)
                                .addOnSuccessListener { codes ->
                                    val value = codes.firstOrNull()?.rawValue
                                    if (!value.isNullOrBlank() && value != lastDecoded) {
                                        lastDecoded = value.trim()
                                        onDecoded(lastDecoded!!)
                                    }
                                }
                                .addOnCompleteListener {
                                    analyzing.set(false)
                                    imageProxy.close()
                                }
                        } catch (t: Throwable) {
                            Log.e(TAG, "Analyzer crash", t)
                            analyzing.set(false)
                            imageProxy.close()
                        }
                    }
                }

            val selector = CameraSelector.DEFAULT_BACK_CAMERA

            try {
                provider.unbindAll()
                provider.bindToLifecycle(
                    this, selector, preview, imageCapture, imageAnalysis
                )
                txtScanValueB.text = "Scan a Location QR..."
            } catch (t: Throwable) {
                Toast.makeText(this, "Camera error: ${t.message}", Toast.LENGTH_LONG).show()
                finish()
            }
        }, ContextCompat.getMainExecutor(this))
    }

    // Called once when a *new* QR is seen
    private fun onDecoded(text: String) {
        locationId = text.trim()
        txtScanValueB.text = locationId

        // take a quick still for audit, then navigate
        takePhoto { savedUri ->
            openSummary(locationId, savedUri)
        }
    }

    private fun takePhoto(onSaved: (Uri?) -> Unit) {
        val cap = imageCapture ?: return onSaved(null)

        val name = "qr_${System.currentTimeMillis()}.jpg"
        val values = ContentValues().apply {
            put(MediaStore.MediaColumns.DISPLAY_NAME, name)
            put(MediaStore.MediaColumns.MIME_TYPE, "image/jpeg")
            put(MediaStore.MediaColumns.RELATIVE_PATH, "DCIM/Camera")
        }
        val output = ImageCapture.OutputFileOptions
            .Builder(contentResolver, MediaStore.Images.Media.EXTERNAL_CONTENT_URI, values)
            .build()

        cap.takePicture(
            output,
            ContextCompat.getMainExecutor(this),
            object : ImageCapture.OnImageSavedCallback {
                override fun onImageSaved(result: ImageCapture.OutputFileResults) {
                    onSaved(result.savedUri)
                }
                override fun onError(exc: ImageCaptureException) {
                    onSaved(null) // proceed even if snapshot fails
                }
            }
        )
    }

    // Handoff
    private fun openSummary(locationId: String, photo: Uri?) {
        if (gatewayId.isBlank() || bedId.isBlank() || locationId.isBlank()) {
            Toast.makeText(this, "Missing IDs", Toast.LENGTH_SHORT).show()
            finish()
            return
        }

        val i = Intent(this, SummaryBActivity::class.java).apply {
            putExtra(EXTRA_GATEWAY, gatewayId)
            putExtra(EXTRA_BED, bedId)
            putExtra(EXTRA_LOCATION, locationId)
            photo?.let { putExtra(EXTRA_IMAGE_URI, it.toString()) }
        }
        startActivity(i)
        finish()
    }
}





