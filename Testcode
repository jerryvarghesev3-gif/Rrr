ll


// ---------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------

private const val TAR_GZ = ".tar.gz"
private const val TAR_GZ_ENC = ".tar.gz.enc"

/**
 * Returns true for "real" tar.gz files and encrypted variants
 * like "firmware_imx6_dynamo.tar.gz.enc".
 */
private fun String.isTarGzLike(): Boolean =
    endsWith(TAR_GZ, ignoreCase = true) || endsWith(TAR_GZ_ENC, ignoreCase = true)






/**
 * Recursively searches a .tar.gz (or .tar.gz.enc) file for a nested
 * .tar.gz (or .tar.gz.enc) file named [secondaryTarGzFileName], then
 * searches that nested tar for a file named [searchFileName].
 *
 * Returns the first instance of [searchFileName] as a ByteArray.
 */
fun searchTarGzFile(
    targzFile2Search: File,
    secondaryTarGzFileName: String,
    searchFileName: String
): Outcome<ByteArray> {

    var outcome: Outcome<ByteArray> =
        Outcome.Error("${targzFile2Search.name} invalid input")

    if (targzFile2Search.exists() &&
        targzFile2Search.name.isTarGzLike() &&
        secondaryTarGzFileName.isTarGzLike()
    ) {
        outcome = try {
            // Step 1: open the outer tar.gz(.enc) and find the nested one
            val firstLevel = TarInputStream(
                BufferedInputStream(
                    GZIPInputStream(targzFile2Search.inputStream())
                )
            )

            when (val found =
                searchTarGzFile(firstLevel, secondaryTarGzFileName)) {

                is Outcome.Ok -> {
                    // Step 2: open the nested tar.gz(.enc) from the bytes we just found
                    val nestedStream = TarInputStream(
                        BufferedInputStream(
                            GZIPInputStream(
                                ByteArrayInputStream(found.value)
                            )
                        )
                    )
                    searchTarGzFile(nestedStream, searchFileName)
                }

                is Outcome.Error ->
                    Outcome.Error("secondaryTarGzFileName: ${found.error}")
            }
        } catch (e: Exception) {
            Outcome.Error("Exception while searching for $secondaryTarGzFileName: $e")
        }
    }

    return outcome
}







/**
 * Recursively searches a tar stream and any contained .tar.gz / .tar.gz.enc
 * files for a file named [searchFileName].
 *
 * Returns the first instance of [searchFileName] as a ByteArray.
 */
fun searchTarGzFile(
    tarStream: TarInputStream,
    searchFileName: String
): Outcome<ByteArray> {

    var outcome: Outcome<ByteArray> =
        Outcome.Error("searchFileName not found")

    try {
        do {
            val entry = tarStream.nextEntry
            if (entry != null) {

                // 1) Direct match for the wanted file
                if (entry.name.contains(searchFileName) && !entry.isDirectory) {

                    var name = entry.name
                    val index = name.lastIndexOf('/')
                    if (index != -1) {
                        // strip path so we only compare the file name
                        name = name.substring(index + 1, entry.name.length)
                    }

                    if (name == searchFileName) {
                        // Copy entry contents into a byte array
                        val buffer = ByteArray(2048)
                        val out = ByteArrayOutputStream()
                        var read: Int

                        while (tarStream.read(buffer).also { read = it } != -1) {
                            out.write(buffer, 0, read)
                        }

                        outcome = Outcome.Ok(out.toByteArray())
                        break
                    }

                // 2) If this entry itself is a nested tar.gz or tar.gz.enc, recurse into it
                } else if (entry.name.isTarGzLike()) {
                    try {
                        val nestedStream = TarInputStream(
                            BufferedInputStream(
                                GZIPInputStream(tarStream)
                            )
                        )

                        when (val result =
                            searchTarGzFile(nestedStream, searchFileName)) {

                            is Outcome.Ok -> {
                                outcome = result
                                break
                            }

                            is Outcome.Error -> {
                                // Ignore and continue scanning other entries
                            }
                        }
                    } catch (e: Exception) {
                        ProLog.e(
                            MODULE_NAME,
                            "searchTarGzFile inner exception = ${e}; " +
                                "while searching ${entry.name} for $searchFileName"
                        )
                    }
                }
            }
        } while (entry != null)
    } catch (e: Exception) {
        ProLog.e(
            MODULE_NAME,
            "searchTarGzFile outer exception = $e; while searching for $searchFileName"
        )
        outcome = Outcome.Error("Exception while searching for $searchFileName: $e")
    }

    return outcome
}




