ll



// somewhere above (already in your file)
private const val algorithm = "AES/GCM/NoPadding"
// encryptionKey must be a SecretKeySpec created from your real key bytes
// e.g. private val encryptionKey = SecretKeySpec(MY_KEY_BYTES, "AES")
private const val GCM_TAG_LENGTH = 16           // bytes (128-bit tag)
private const val GCM_NONCE_LENGTH = 12         // bytes (96-bit IV)

// ---- Decrypt an .enc file -> plainOut ----
private fun decryptEncFileTo(encFile: File, plainOut: File) {
    FileInputStream(encFile).use { fis ->
        // 1) read IV/nonce (exactly 12 bytes). Make sure we fill the buffer fully.
        val iv = ByteArray(GCM_NONCE_LENGTH)
        var off = 0
        while (off < iv.size) {
            val r = fis.read(iv, off, iv.size - off)
            if (r == -1) throw IllegalStateException("Encrypted file missing IV")
            off += r
        }

        // 2) init GCM cipher with your existing encryptionKey
        val spec = GCMParameterSpec(GCM_TAG_LENGTH * 8, iv)   // length in BITS
        val cipher = javax.crypto.Cipher.getInstance(algorithm)
        cipher.init(javax.crypto.Cipher.DECRYPT_MODE, encryptionKey, spec)

        // 3) stream-decrypt the rest of the file (ciphertext + tag)
        javax.crypto.CipherInputStream(fis, cipher).use { cis ->
            FileOutputStream(plainOut).use { fos ->
                val buf = ByteArray(8 * 1024)
                while (true) {
                    val n = cis.read(buf)
                    if (n == -1) break
                    fos.write(buf, 0, n)
                }
                fos.fd.sync()
            }
        }
    }
}












override suspend fun extractFirmwareFile(
    firmwareFileInputStream: InputStream
): Outcome<SoftwareReleaseManifest> = withContext(Dispatchers.IO) {

    // 1) Write the incoming BAS to a temp file in cache (auto-clean it)
    val basFile = File.createTempFile("firmware", ".bas", context.cacheDir).apply {
        deleteOnExit()
    }

    try {
        firmwareFileInputStream.use { input ->
            basFile.outputStream().buffered().use { out ->
                input.copyTo(out, DEFAULT_BUFFER_SIZE)
                out.flush()
            }
        }

        // 2) Reset extraction folder
        if (extractionFolder.exists()) extractionFolder.deleteRecursively()
        if (!extractionFolder.mkdirs() && !extractionFolder.exists()) {
            ProLog.w(MODULE_NAME, "Unable to create extraction folder: ${extractionFolder.absolutePath}")
            return@withContext Outcome.Error(DynamoFirmwareCompatibilityStatus.Error)
        }

        // 3) Extract BAS contents
        if (!dynamo.extractBasFile(basFile.absolutePath, extractionFolder.absolutePath)) {
            ProLog.w(MODULE_NAME, "Unable to extract bas file: ${basFile.name}")
            return@withContext Outcome.Error(DynamoFirmwareCompatibilityStatus.Error)
        }

        // 4) Locate manifest (robust: any depth, common names)
        val manifestFile = extractionFolder
            .walkTopDown()
            .firstOrNull { f ->
                f.isFile && (
                    f.name.equals("manifest.json", true) ||
                    f.name.equals("manifest", true) ||
                    f.name.contains("manifest", true)
                )
            }
            ?: return@withContext Outcome.Error(DynamoFirmwareCompatibilityStatus.Error)

        // 5) Parse manifest
        val releaseManifest = try {
            manifestFile.inputStream().buffered().use { ManifestParser().parse(it) }
        } catch (e: Exception) {
            ProLog.w(MODULE_NAME, "Unable to parse manifest file: ${e.message}")
            return@withContext Outcome.Error(e)
        }

        Outcome.Ok(releaseManifest)
    } catch (e: Exception) {
        ProLog.e(MODULE_NAME, "extractFirmwareFile exception: ${e.message}")
        Outcome.Error(e)
    } finally {
        // 6) Always clean up the temp BAS
        runCatching { basFile.delete() }
    }
}
