(MEM_MEMORY_TYPE_INTERNAL_FLASH == memoryType)
{
    if (GN2A_SOM == destination)
    {
        const QString baseDir = binPath;

        // --- find SOM tar ---
        QRegularExpression tarRx("^dynamoSOMApp.*\\.tar\\.gz\\.enc$");
        int tarIndex = binariesFound.indexOf(tarRx);
        if (tarIndex < 0)
        {
            ProLog().w(MODULE_NAME, "SOM tar not found");
            onBoardUpgraded(nullptr, destination, false);
            return;
        }

        const QString somTarName = binariesFound.at(tarIndex);
        const QString somTarPath = baseDir + "/" + somTarName;

        // --- find decrypt (optional) ---
        QRegularExpression decryptRx("^decrypt(\\..+)?$");
        int decryptIndex = binariesFound.indexOf(decryptRx);

        QString decryptName;
        QString decryptPath;
        if (decryptIndex >= 0)
        {
            decryptName = binariesFound.at(decryptIndex);
            decryptPath = baseDir + "/" + decryptName;
        }

        auto fillReqName = [](MEM_SendImageFileNameRequest &req, const QString &name) {
            memset(req.imageName, 0, sizeof(req.imageName));
            QByteArray n = name.toUtf8();
            const int copyLen = std::min<int>(n.size(), (int)sizeof(req.imageName) - 1);
            memcpy(req.imageName, n.constData(), copyLen);
        };

        // ---- CASE 1: decrypt exists ----
        if (!decryptName.isEmpty())
        {
            ProLog().i(MODULE_NAME, ("Uploading decrypt first: " + decryptName).toStdString());

            // 1) DECRYPT upload object
            FirmwareUpdateCAN* fwDecrypt = new FirmwareUpdateCAN();
            fwDecrypt->onChangedSelectedServer(addressForUpdate, serverBoard, NULL);
            fwDecrypt->setDestination(destination);

            fwDecrypt->setImageData(decryptPath);

            MEM_SendImageFileNameRequest req = MEM_SendImageFileNameRequest_init_zero;
            MEM_SendImageFileNameResponse rsp = MEM_SendImageFileNameResponse_init_zero;
            req.memoryType = memoryType;
            fillReqName(req, decryptName);

            if (CMD_OK != MEM_SendImageFileName(GN2A_SOM, &req, &rsp))
            {
                onBoardUpgraded(fwDecrypt, destination, false);
                return;
            }

            // When decrypt upload completes -> start TAR upload (new object)
            connect(fwDecrypt,
                    &FirmwareUpdateCAN::imageUploadCompleted,
                    this,
                    [=](FirmwareUpdateCAN* /*fw*/, quint32 /*board*/, bool ok1)
                    {
                        if (!ok1) {
                            ProLog().w(MODULE_NAME, "Decrypt upload failed");
                            onBoardUpgraded(fwDecrypt, destination, false);
                            return;
                        }

                        ProLog().i(MODULE_NAME, ("Decrypt OK. Uploading tar second: " + somTarName).toStdString());

                        // 2) TAR upload object (separate!)
                        FirmwareUpdateCAN* fwTar = new FirmwareUpdateCAN();
                        fwTar->onChangedSelectedServer(addressForUpdate, serverBoard, NULL);
                        fwTar->setDestination(destination);

                        fwTar->setImageData(somTarPath);

                        MEM_SendImageFileNameRequest req2 = MEM_SendImageFileNameRequest_init_zero;
                        MEM_SendImageFileNameResponse rsp2 = MEM_SendImageFileNameResponse_init_zero;
                        req2.memoryType = memoryType;
                        fillReqName(req2, somTarName);

                        if (CMD_OK != MEM_SendImageFileName(GN2A_SOM, &req2, &rsp2))
                        {
                            onBoardUpgraded(fwTar, destination, false);
                            return;
                        }

                        // Final completion driven by TAR upload completion
                        connect(fwTar,
                                &FirmwareUpdateCAN::imageUploadCompleted,
                                this,
                                [=](FirmwareUpdateCAN* /*fw*/, quint32 /*board*/, bool ok2)
                                {
                                    ProLog().i(MODULE_NAME, (QString("TAR upload done ok=%1").arg(ok2)).toStdString());
                                    onBoardUpgraded(fwTar, destination, ok2);
                                },
                                Qt::QueuedConnection);

                        fwTar->startUpdate(memoryType, false);
                    },
                    Qt::QueuedConnection);

            fwDecrypt->startUpdate(memoryType, false);
            return; // SOM special path only
        }

        // ---- CASE 2: NO decrypt (old behavior) ----
        ProLog().i(MODULE_NAME, ("Uploading tar only: " + somTarName).toStdString());

        FirmwareUpdateCAN* fw = new FirmwareUpdateCAN();
        fw->onChangedSelectedServer(addressForUpdate, serverBoard, NULL);
        fw->setDestination(destination);
        fw->setImageData(somTarPath);

        MEM_SendImageFileNameRequest req = MEM_SendImageFileNameRequest_init_zero;
        MEM_SendImageFileNameResponse rsp = MEM_SendImageFileNameResponse_init_zero;
        req.memoryType = memoryType;
        fillReqName(req, somTarName);

        if (CMD_OK != MEM_SendImageFileName(GN2A_SOM, &req, &rsp))
        {
            onBoardUpgraded(fw, destination, false);
            return;
        }

        fw->startUpdate(memoryType, false);
        return;
    }

    // âœ… everything below remains EXACTLY as before (other boards via MCB)
}
