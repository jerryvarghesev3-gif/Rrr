private fun startCamera() {
    val cameraProviderFuture = ProcessCameraProvider.getInstance(this)
    cameraProviderFuture.addListener({
        val cameraProvider = cameraProviderFuture.get()

        val preview = Preview.Builder().build().also {
            it.setSurfaceProvider(previewView.surfaceProvider)
        }

        imageCapture = ImageCapture.Builder()
            .setCaptureMode(ImageCapture.CAPTURE_MODE_MINIMIZE_LATENCY)
            .build()

        val imageAnalysis = ImageAnalysis.Builder()
            .setBackpressureStrategy(ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)
            .build()

        imageAnalysis.setAnalyzer(cameraExecutor) { proxy ->
            val mediaImage = proxy.image
            if (mediaImage == null) { proxy.close(); return@setAnalyzer }

            // Donâ€™t hammer ML Kit if we already have a value
            if (!analyzing.get()) { proxy.close(); return@setAnalyzer }

            val rotation = proxy.imageInfo.rotationDegrees
            val image = InputImage.fromMediaImage(mediaImage, rotation)

            barcodeScanner.process(image)
                .addOnSuccessListener { barcodes ->
                    val first = barcodes.firstOrNull()?.rawValue
                    if (!first.isNullOrBlank()) {
                        // stop further analysis until user taps RESCAN
                        if (analyzing.compareAndSet(true, false)) {
                            lastDecoded = first
                            runOnUiThread { txtScanValue.text = first }
                        }
                    }
                }
                .addOnFailureListener {
                    // ignore; keep analyzing next frame
                }
                .addOnCompleteListener {
                    // ALWAYS close the frame
                    proxy.close()
                }
        }

        val selector = CameraSelector.DEFAULT_BACK_CAMERA

        cameraProvider.unbindAll()
        cameraProvider.bindToLifecycle(
            this, selector, preview, imageCapture, imageAnalysis
        )

        // allow scanning immediately
        analyzing.set(true)
    }, ContextCompat.getMainExecutor(this))
}












@OptIn(ExperimentalGetImage::class)
private fun startCamera() {
    val cameraProviderFuture = ProcessCameraProvider.getInstance(this)

    cameraProviderFuture.addListener({
        val cameraProvider = cameraProviderFuture.get()

        // --- Preview ---
        val preview = Preview.Builder()
            .setTargetRotation(previewView.display?.rotation ?: Surface.ROTATION_0)
            .build().also { it.setSurfaceProvider(previewView.surfaceProvider) }

        // --- Still Image capture (for saving a frame when you press Continue) ---
        imageCapture = ImageCapture.Builder()
            .setCaptureMode(ImageCapture.CAPTURE_MODE_MINIMIZE_LATENCY)
            .setTargetRotation(previewView.display?.rotation ?: Surface.ROTATION_0)
            .build()

        // --- Analyzer for QR codes ---
        val imageAnalysis = ImageAnalysis.Builder()
            .setBackpressureStrategy(ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)
            .setTargetRotation(previewView.display?.rotation ?: Surface.ROTATION_0)
            .build()

        val scanner = BarcodeScanning.getClient(
            BarcodeScannerOptions.Builder()
                .setBarcodeFormats(Barcode.FORMAT_QR_CODE) // QR only (add more if you need)
                .build()
        )

        imageAnalysis.setAnalyzer(cameraExecutor) { imageProxy ->
            try {
                val media = imageProxy.image ?: run {
                    imageProxy.close(); return@setAnalyzer
                }
                val input = InputImage.fromMediaImage(media, imageProxy.imageInfo.rotationDegrees)

                scanner.process(input)
                    .addOnSuccessListener { codes ->
                        val v = codes.firstOrNull()?.rawValue
                        if (!v.isNullOrBlank()) {
                            lastDecoded = v
                            runOnUiThread {
                                txtScanValue.text = v
                                btnContinue.isEnabled = true
                            }
                        }
                    }
                    .addOnFailureListener { e ->
                        Log.e("QR", "Scan failed", e)
                    }
                    .addOnCompleteListener {
                        imageProxy.close()        // ALWAYS close the frame
                    }
            } catch (t: Throwable) {
                Log.e("QR", "Analyzer crash", t)
                imageProxy.close()
            }
        }

        // --- Bind everything ---
        val selector = CameraSelector.DEFAULT_BACK_CAMERA
        cameraProvider.unbindAll()
        cameraProvider.bindToLifecycle(
            this, selector,
            preview, imageCapture, imageAnalysis
        )
    }, ContextCompat.getMainExecutor(this))
}





private fun takePhoto(onSaved: (Uri) -> Unit, onError: (Exception) -> Unit) {
    val photoFile = File(cacheDir, "qr_${System.currentTimeMillis()}.jpg")
    val output = ImageCapture.OutputFileOptions.Builder(photoFile).build()

    imageCapture.takePicture(
        output,
        cameraExecutor,
        object : ImageCapture.OnImageSavedCallback {
            override fun onImageSaved(result: ImageCapture.OutputFileResults) {
                onSaved(Uri.fromFile(photoFile))
            }
            override fun onError(exc: ImageCaptureException) {
                onError(exc)
            }
        }
    )
}












class SummaryActivity : AppCompatActivity() {

    private lateinit var tvGateway: TextView
    private lateinit var tvBed: TextView
    private lateinit var tvLocation: TextView
    private lateinit var img: ImageView
    private lateinit var btnDone: Button

    private var gatewayId = ""
    private var bedId = ""
    private var locationId = ""

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_summary)

        tvGateway = findViewById(R.id.tvGateway)
        tvBed     = findViewById(R.id.tvBed)
        tvLocation= findViewById(R.id.tvLocation)
        img       = findViewById(R.id.imgPreview)
        btnDone   = findViewById(R.id.btnDone)

        // 1) read extras
        gatewayId  = intent.getStringExtra(EXTRA_GATEWAY).orEmpty()
        bedId      = intent.getStringExtra(EXTRA_BED).orEmpty()
        locationId = intent.getStringExtra(EXTRA_LOCATION).orEmpty()

        // 2) visual debug
        tvGateway.text  = "Gateway: $gatewayId"
        tvBed.text      = "Bed ID: $bedId"
        tvLocation.text = "Location ID: $locationId"

        intent.getStringExtra(EXTRA_IMAGE_URI)?.let { s ->
            runCatching { img.setImageURI(Uri.parse(s)) }
        }

        // 3) enable Done only if all present
        btnDone.isEnabled = gatewayId.isNotBlank() && bedId.isNotBlank() && locationId.isNotBlank()

        btnDone.setOnClickListener {
            if (gatewayId.isBlank() || bedId.isBlank() || locationId.isBlank()) {
                Toast.makeText(this, "Missing data. Scan again.", Toast.LENGTH_LONG).show()
                return@setOnClickListener
            }
            // call your existing MQTT set_location using these *non-empty* values
            sendSetLocation(gatewayId, bedId, locationId)
        }
    }
}
