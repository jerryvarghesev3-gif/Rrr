ll


private fun sendSetLocation(force: Boolean = false) {
    val c = MqttHolder.readyClientOrNull() ?: run {
        setStatus("MQTT not ready"); btnAdd.isEnabled = true; return
    }

    lastTxnSetLoc += 1

    val data = JSONObject()
        .put("bed_id", bedId)
        .put("force", force)              // ← key to suppress device popup
        .put("location_id", locationId)

    val req = JSONObject()
        .put("command_id", "set_location")
        .put("data", data)
        .put("reply_to", topicSetLocationResp(bedId))
        .put("transaction_id", lastTxnSetLoc)

    val payload = req.toString().toByteArray(Charsets.UTF_8)

    c.publish(
        topicSetLocationReq(gatewayId),
        payload,
        1, false, null,
        object : IMqttActionListener {
            override fun onSuccess(asyncActionToken: IMqttToken?) {
                setStatus("Sent set_location (tx=$lastTxnSetLoc)")
            }
            override fun onFailure(asyncActionToken: IMqttToken?, exception: Throwable?) {
                toast("Publish failed: ${exception?.message}")
                ui { btnAdd.isEnabled = true }
            }
        }
    )
}




private fun onSetLocationResponse(json: String) {
    try {
        val obj = JSONObject(json)
        val tx  = obj.optInt("transaction_id", -1)
        if (tx != lastTxnSetLoc) return  // ignore old/other replies

        val status = obj.optInt("status", -1)
        when (status) {
            0 -> {
                val loc = obj.optJSONObject("data")
                    ?.optJSONObject("location")
                    ?.optString("id") ?: locationId

                setStatus("Location set OK → $loc")

                // go to Summary
                val intent = Intent(this, SummaryActivity::class.java).apply {
                    putExtra("gatewayId", gatewayId)
                    putExtra("bedId", bedId)
                    putExtra("locationId", loc)
                    putExtra("status", 0)
                }
                startActivity(intent)
                finish()
            }

            // override/already-associated codes – treat as success or auto-resend with force
            98, 99 -> {
                // If you want to auto-accept:
                setStatus("Override accepted")
                val intent = Intent(this, SummaryActivity::class.java).apply {
                    putExtra("gatewayId", gatewayId)
                    putExtra("bedId", bedId)
                    putExtra("locationId", locationId)
                    putExtra("status", 0)
                }
                startActivity(intent)
                finish()

                // If your backend actually requires a re-send, use this instead:
                // setStatus("Override required, retrying…")
                // sendSetLocation(force = true)
            }

            else -> {
                setStatus("set_location failed (status=$status)")
                ui { btnAdd.isEnabled = true }
            }
        }
    } catch (t: Throwable) {
        setStatus("Bad response: ${t.message}")
        ui { btnAdd.isEnabled = true }
    }
}





private fun prepareMqttForSetLocation() {
    val c = MqttHolder.readyClientOrNull() ?: run {
        setStatus("MQTT not connected"); return
    }

    // subscribe the response topic
    c.subscribe(topicSetLocationResp(bedId), 1, null, object : IMqttActionListener {
        override fun onSuccess(asyncActionToken: IMqttToken?) { /* optional: toast("Listening…") */ }
        override fun onFailure(asyncActionToken: IMqttToken?, exception: Throwable?) {
            toast("Subscribe failed: ${exception?.message}")
        }
    })

    // ensure the callback routes set_location replies here
    c.setCallback(object : MqttCallbackExtended {
        override fun connectComplete(reconnect: Boolean, serverURI: String?) {}
        override fun connectionLost(cause: Throwable?) { /* optional UI */ }
        override fun deliveryComplete(token: IMqttDeliveryToken?) {}

        override fun messageArrived(topic: String?, message: MqttMessage?) {
            val payload = message?.toString().orEmpty()
            if (topic == topicSetLocationResp(bedId)) {
                ui { onSetLocationResponse(payload) }   // run on UI thread
            }
        }
    })
}


