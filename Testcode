ngineer"}
Dear Hiring Manager,

I am a Senior Embedded & IoT Software Engineer with over 9 years of R&D-driven experience developing Linux-based embedded systems and multi-layer connected platforms across medical, automotive, industrial, and public infrastructure domains. My background spans full product lifecycles, from board bring-up and BSP customization to secure communication, OTA firmware upgrades, and field-deployed diagnostic tools in regulated environments.

In my recent roles, I have led firmware integration across multi-board architectures, designed secure MCU–SOM communication pipelines, and developed Android- and Qt-based diagnostic and provisioning tools supporting production validation and remote servicing. I have worked extensively with STM32 and NXP i.MX platforms, CAN/I2C/SPI/UART/MQTT communication stacks, and Yocto-based build systems, while adhering to stringent quality and safety standards including IEC 62304 and MISRA-C/C++ compliance.

I am currently based in Bangalore, India, and am actively seeking opportunities across Europe, with a strong motivation for long-term relocation and contribution to product-focused engineering teams. I am particularly interested in roles where deep embedded expertise, system-level ownership, and cross-domain problem-solving are valued. I would welcome the opportunity to discuss how my experience can support your organization’s engineering goals.

Kind regards,  
Jerry V  
Senior Embedded & IoT Software Engineer  
Bangalore, India  
Email: jerryv@gmail.com  
LinkedIn: https://www.linkedin.











void Firmware::updateBoard(quint32 destination, MEM_MEMORY_TYPE memoryType, QString binPath)
{
    updateComplete[destination] = false;
    updateSuccessful[destination] = false;

    QString board = boardsList[destination];
    GN2_Address addressForUpdate = GN2A_MCB;
    QString serverBoard;

    RPCA_Plant* rp = RPCA_Plant::getInstance();
    if ((!rp->isConnectedTo(GN2A_MCB)) && (destination == GN2A_ATLAS))
    {
        addressForUpdate = GN2A_ATLAS;
    }

    serverBoard = boardsList[addressForUpdate];

    ProLog().i(MODULE_NAME, ("Firmware upgrade started on " + board).toStdString());

    // -------------------------
    // INTERNAL FLASH
    // -------------------------
    if (MEM_MEMORY_TYPE_INTERNAL_FLASH == memoryType)
    {
        // =========================================================
        // ✅ SPECIAL CASE: SOM (upload tar, then upload decrypt if exists)
        // =========================================================
        if (GN2A_SOM == destination)
        {
            // IMPORTANT: binPath is a folder. Keep it untouched.
            const QString baseDir = binPath;

            // Find SOM tar in folder
            QRegularExpression tarRx("^dynamoSOMApp.*\\.tar\\.gz\\.enc$");
            int indexOfTarBinary = binariesFound.indexOf(tarRx);

            if (indexOfTarBinary < 0)
            {
                ProLog().w(MODULE_NAME, ("SOM tar not found in folder: " + baseDir).toStdString());
                onBoardUpgraded(nullptr, destination, false);
                return; // ✅ stop here
            }

            const QString somFileName = binariesFound.at(indexOfTarBinary);
            const QString somTarPath  = baseDir + "/" + somFileName;

            // Optional: decrypt (decrypt or decrypt.<something>)
            QRegularExpression decryptRx("^decrypt(\\..+)?$");
            int indexOfDecrypt = binariesFound.indexOf(decryptRx);

            QString decryptFileName;
            QString decryptPath;
            const bool hasDecrypt = (indexOfDecrypt > -1);

            if (hasDecrypt)
            {
                decryptFileName = binariesFound.at(indexOfDecrypt);
                decryptPath     = baseDir + "/" + decryptFileName;
            }

            // ---- Create uploader for SOM tar ----
            FirmwareUpdateCAN* fw = new FirmwareUpdateCAN();
            fw->setImageData(somTarPath); // ✅ FULL PATH: folder + filename
            fw->onChangedSelectedServer(addressForUpdate, serverBoard, NULL);
            fw->setDestination(destination);

            // Tell SOM which filename it should store
            MEM_SendImageFileNameRequest req = MEM_SendImageFileNameRequest_init_zero;
            MEM_SendImageFileNameResponse rsp = MEM_SendImageFileNameResponse_init_zero;
            req.memoryType = memoryType;

            // ✅ Safer than memcpy: ensure null-terminated and no overflow
            QByteArray somNameArr = somFileName.toUtf8();
            std::memset(req.imageName, 0, sizeof(req.imageName));
            std::strncpy(req.imageName, somNameArr.constData(), sizeof(req.imageName) - 1);

            ProLog().i(MODULE_NAME, ("Downloading " + somFileName + " to SOM").toStdString());

            if (CMD_OK != MEM_SendImageFileName(GN2A_SOM, &req, &rsp))
            {
                ProLog().w(MODULE_NAME, "Could not send SOM tar file info");
                onBoardUpgraded(fw, destination, false);
                return; // ✅ stop here
            }

            // ✅ If decrypt exists: chain decrypt AFTER tar upload completes
            if (hasDecrypt)
            {
                connect(fw, &FirmwareUpdateCAN::imageUploadCompleted, this, [=]() {

                    ProLog().i(MODULE_NAME, ("Downloading " + decryptFileName + " to SOM").toStdString());

                    FirmwareUpdateCAN* fw2 = new FirmwareUpdateCAN();
                    fw2->setImageData(decryptPath); // ✅ FULL PATH: folder + decrypt file
                    fw2->onChangedSelectedServer(addressForUpdate, serverBoard, NULL);
                    fw2->setDestination(destination);

                    MEM_SendImageFileNameRequest req2 = MEM_SendImageFileNameRequest_init_zero;
                    MEM_SendImageFileNameResponse rsp2 = MEM_SendImageFileNameResponse_init_zero;
                    req2.memoryType = memoryType;

                    QByteArray decNameArr = decryptFileName.toUtf8();
                    std::memset(req2.imageName, 0, sizeof(req2.imageName));
                    std::strncpy(req2.imageName, decNameArr.constData(), sizeof(req2.imageName) - 1);

                    if (CMD_OK != MEM_SendImageFileName(GN2A_SOM, &req2, &rsp2))
                    {
                        ProLog().w(MODULE_NAME, "Could not send decrypt file info");
                        onBoardUpgraded(fw2, destination, false);
                        return;
                    }

                    // ✅ Normal signals for decrypt
                    connect(fw2, &FirmwareUpdateCAN::imageUploadCompleted, this, &Firmware::onBoardUpgraded);
                    connect(fw2, &FirmwareUpdateCAN::errorNotification,    this, &Firmware::onBoardUpgraded);
                    connect(fw2, &FirmwareUpdateCAN::infoNotification,     this, &Firmware::onObservedInfo);
                    connect(fw2, &FirmwareUpdateCAN::progressObserved,     this, &Firmware::onObservedProgress);
                    connect(fw2, &FirmwareUpdateCAN::newProgressPhaseStarted, this, &Firmware::onPhaseChanged);
                    connect(this, &Firmware::abortUpgrade, fw2, &FirmwareUpdateCAN::abortUpgrade, Qt::DirectConnection);

                    currentMemoryType = memoryType;
                    fw2->startUpdate(memoryType, false);
                }, Qt::QueuedConnection);

                // ✅ IMPORTANT: For tar stage, do NOT call onBoardUpgraded on upload complete
                // because we still need decrypt. Only error should fail immediately.
                connect(fw, &FirmwareUpdateCAN::errorNotification, this, &Firmware::onBoardUpgraded);
            }
            else
            {
                // No decrypt -> normal completion behavior
                connect(fw, &FirmwareUpdateCAN::imageUploadCompleted, this, &Firmware::onBoardUpgraded);
                connect(fw, &FirmwareUpdateCAN::errorNotification,    this, &Firmware::onBoardUpgraded);
            }

            // Common signals
            connect(fw, &FirmwareUpdateCAN::infoNotification,     this, &Firmware::onObservedInfo);
            connect(fw, &FirmwareUpdateCAN::progressObserved,     this, &Firmware::onObservedProgress);
            connect(fw, &FirmwareUpdateCAN::newProgressPhaseStarted, this, &Firmware::onPhaseChanged);
            connect(this, &Firmware::abortUpgrade, fw, &FirmwareUpdateCAN::abortUpgrade, Qt::DirectConnection);

            // (Optional) Your existing validate step if you have it
            if (!fw->validateImage(memoryType, false))
            {
                ProLog().w(MODULE_NAME, ("Image Verification failed on " + board).toStdString());
                onBoardUpgraded(fw, destination, false);
                return;
            }

            currentMemoryType = memoryType;
            fw->startUpdate(memoryType, false);
            return; // ✅ done with SOM path
        }

        // =========================================================
        // ✅ EXISTING CODE FOR OTHER BOARDS (MINIMAL CHANGE)
        // =========================================================
        // Your original logic: pick internal binary based on destination
        binPath.append("/");
        binPath.append(internalBinaries[destination]);

        // Do not toggle banks for internal memory
        toggleBankOnCurrentBoard = false;
    }

    // -------------------------
    // EXTERNAL FLASH
    // -------------------------
    else if (MEM_MEMORY_TYPE_EXTERNAL_FLASHO == memoryType)
    {
        toggleBankOnCurrentBoard = false;
        binPath.append("/");
        binPath.append(externalImages[destination]);
    }

    // -------------------------
    // Common uploader for non-SOM boards
    // -------------------------
    ProLog().i(MODULE_NAME, ("Image path: " + binPath).toStdString());

    FirmwareUpdateCAN* fw = new FirmwareUpdateCAN();
    fw->setImageData(binPath);
    fw->onChangedSelectedServer(addressForUpdate, serverBoard, NULL);
    fw->setDestination(destination);

    // Existing SOM filename handshake is not needed here since we returned already above.

    if (!fw->validateImage(memoryType, false))
    {
        ProLog().w(MODULE_NAME, ("Image Verification failed on " + board).toStdString());
        onBoardUpgraded(fw, destination, false);
        return;
    }

    connect(fw, &FirmwareUpdateCAN::imageUploadCompleted, this, &Firmware::onBoardUpgraded);
    connect(fw, &FirmwareUpdateCAN::errorNotification,    this, &Firmware::onBoardUpgraded);
    connect(fw, &FirmwareUpdateCAN::infoNotification,     this, &Firmware::onObservedInfo);
    connect(fw, &FirmwareUpdateCAN::progressObserved,     this, &Firmware::onObservedProgress);
    connect(fw, &FirmwareUpdateCAN::newProgressPhaseStarted, this, &Firmware::onPhaseChanged);
    connect(this, &Firmware::abortUpgrade, fw, &FirmwareUpdateCAN::abortUpgrade, Qt::DirectConnection);

    currentMemoryType = memoryType;
    fw->startUpdate(memoryType, toggleBankOnCurrentBoard);
}
