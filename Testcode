kk



package com.connect.connection

import android.Manifest
import android.content.Intent
import android.content.pm.PackageManager
import android.os.Build
import android.os.Bundle
import android.view.View
import android.widget.Button
import android.widget.TextView
import android.widget.Toast
import androidx.activity.ComponentActivity
import androidx.camera.core.CameraSelector
import androidx.camera.core.ExperimentalGetImage
import androidx.camera.core.ImageAnalysis
import androidx.camera.core.Preview
import androidx.camera.lifecycle.ProcessCameraProvider
import androidx.camera.view.PreviewView
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat
import com.google.mlkit.vision.barcode.BarcodeScannerOptions
import com.google.mlkit.vision.barcode.BarcodeScanning
import com.google.mlkit.vision.common.InputImage
import org.eclipse.paho.client.mqttv3.IMqttActionListener
import org.eclipse.paho.client.mqttv3.IMqttDeliveryToken
import org.eclipse.paho.client.mqttv3.IMqttToken
import org.eclipse.paho.client.mqttv3.MqttCallbackExtended
import org.eclipse.paho.client.mqttv3.MqttMessage
import org.json.JSONObject
import java.util.concurrent.atomic.AtomicInteger

class QRBActivity : ComponentActivity() {

    private lateinit var previewView: PreviewView
    private lateinit var txtInfo: TextView
    private lateinit var btnAdd: Button
    private lateinit var btnCancel: Button
    private lateinit var btnRescan: Button

    private lateinit var gatewayId: String
    private lateinit var bedId: String
    private var locationId: String? = null
    private var scanning = true

    private val txnGen = AtomicInteger(200)
    private var lastTxnSetLoc = -1

    private fun ui(block: () -> Unit) = runOnUiThread(block)

    private fun topicSetLocationReq(gw: String) =
        "2.0/aa/bb/gateway/$gw/command/set_location/request"
    private fun topicSetLocationResp(bed: String) =
        "2.0/aa/bb/cc/$bed/command/set_location/response"

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_qrb)

        gatewayId = intent.getStringExtra("gatewayId") ?: ""
        bedId     = intent.getStringExtra("bedId") ?: ""

        previewView = findViewById(R.id.previewViewB)
        txtInfo     = findViewById(R.id.qrTextB)
        btnAdd      = findViewById(R.id.btnAddB)
        btnCancel   = findViewById(R.id.btnCancelB)
        btnRescan   = findViewById(R.id.btnRescanB)

        btnAdd.isEnabled = false
        btnCancel.setOnClickListener { finish() }
        btnRescan.setOnClickListener {
            scanning = true; locationId = null
            txtInfo.text = "Aim at locationId QR"
            btnAdd.isEnabled = false
        }
        btnAdd.setOnClickListener { sendSetLocation() }

        ensureCameraThenStart()
        prepareMqtt()
    }

    private fun prepareMqtt() {
        val c = MqttHolder.readyClientOrNull()
        if (c == null) { Toast.makeText(this, "MQTT not ready", Toast.LENGTH_LONG).show(); finish(); return }

        c.subscribe(topicSetLocationResp(bedId), 1, null, object : IMqttActionListener {
            override fun onSuccess(asyncActionToken: IMqttToken?) {}
            override fun onFailure(asyncActionToken: IMqttToken?, exception: Throwable?) {
                ui { Toast.makeText(this@QRBActivity, "Subscribe failed: ${exception?.message}", Toast.LENGTH_SHORT).show() }
            }
        })

        c.setCallback(object : MqttCallbackExtended {
            override fun connectComplete(reconnect: Boolean, serverURI: String?) {}
            override fun connectionLost(cause: Throwable?) {}
            override fun deliveryComplete(token: IMqttDeliveryToken?) {}
            override fun messageArrived(topic: String?, message: MqttMessage?) {
                if (topic == topicSetLocationResp(bedId)) {
                    ui { onSetLocationResp(message?.toString().orEmpty()) }
                }
            }
        })
    }

    private fun ensureCameraThenStart() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M &&
            ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA)
            != PackageManager.PERMISSION_GRANTED) {
            ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.CAMERA), 3002)
        } else startCamera()
    }

    @OptIn(ExperimentalGetImage::class)
    private fun startCamera() {
        val future = ProcessCameraProvider.getInstance(this)
        future.addListener({
            val provider = future.get()
            val preview = Preview.Builder().build().also {
                it.setSurfaceProvider(previewView.surfaceProvider)
            }
            val selector = CameraSelector.DEFAULT_BACK_CAMERA

            val analysis = ImageAnalysis.Builder()
                .setBackpressureStrategy(ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)
                .build()

            analysis.setAnalyzer(ContextCompat.getMainExecutor(this)) { imageProxy ->
                val media = imageProxy.image ?: run { imageProxy.close(); return@setAnalyzer }
                val image = InputImage.fromMediaImage(media, imageProxy.imageInfo.rotationDegrees)
                val scanner = BarcodeScanning.getClient(
                    BarcodeScannerOptions.Builder()
                        .setBarcodeFormats(com.google.mlkit.vision.barcode.common.Barcode.FORMAT_QR_CODE)
                        .build()
                )
                scanner.process(image)
                    .addOnSuccessListener { codes ->
                        val text = codes.firstOrNull()?.rawValue
                        if (!text.isNullOrBlank() && scanning) {
                            scanning = false
                            locationId = text.trim()
                            txtInfo.text = "locationId: $locationId"
                            btnAdd.isEnabled = true
                        }
                    }
                    .addOnCompleteListener { imageProxy.close() }
            }

            provider.unbindAll()
            provider.bindToLifecycle(this, selector, preview, analysis)
            previewView.visibility = View.VISIBLE
            txtInfo.text = "Aim at locationId QR"
        }, ContextCompat.getMainExecutor(this))
    }

    override fun onRequestPermissionsResult(code: Int, perms: Array<out String>, res: IntArray) {
        super.onRequestPermissionsResult(code, perms, res)
        if (code == 3002 && res.isNotEmpty() && res[0] == PackageManager.PERMISSION_GRANTED) startCamera()
        else Toast.makeText(this, "Camera permission required", Toast.LENGTH_LONG).show()
    }

    // ---------- FIXED PUBLISH: uses byte[] overload + userContext=null ----------
    private fun sendSetLocation() {
        val loc = locationId ?: run {
            ui { Toast.makeText(this, "Scan locationId first", Toast.LENGTH_SHORT).show() }
            return
        }
        val client = MqttHolder.readyClientOrNull()
            ?: run { ui { Toast.makeText(this, "Not connected", Toast.LENGTH_SHORT).show() }; return }

        lastTxnSetLoc = txnGen.incrementAndGet()

        val data = JSONObject()
            .put("bb_id", bedId)
            .put("force", false)
            .put("location_id", loc)

        val req = JSONObject()
            .put("command_id", "set_location")
            .put("data", data)
            .put("reply_to", topicSetLocationResp(bedId))
            .put("transaction_id", lastTxnSetLoc)

        val payload = req.toString().toByteArray(Charsets.UTF_8)

        client.publish(
            topicSetLocationReq(gatewayId),
            payload,      // byte[]
            1,            // qos
            false,        // retained
            null,         // userContext MUST be null
            object : IMqttActionListener {
                override fun onSuccess(asyncActionToken: IMqttToken?) {
                    ui { txtInfo.text = "Sent set_location (tx=$lastTxnSetLoc)â€¦" }
                }
                override fun onFailure(asyncActionToken: IMqttToken?, exception: Throwable?) {
                    ui { Toast.makeText(this@QRBActivity, "Publish failed: ${exception?.message}", Toast.LENGTH_SHORT).show() }
                }
            }
        )
    }
    // ---------------------------------------------------------------------------

    private fun onSetLocationResp(json: String) {
        try {
            val obj = JSONObject(json)
            val tx = obj.optInt("transaction_id", -1)
            if (tx != lastTxnSetLoc) return

            val status = obj.optInt("status", -1)
            val resultLoc = obj.optJSONObject("data")
                ?.optJSONObject("location")
                ?.optString("id") ?: locationId.orEmpty()

            startActivity(
                Intent(this, SummaryActivity::class.java)
                    .putExtra("status", status)
                    .putExtra("gatewayId", gatewayId)
                    .putExtra("bedId", bedId)
                    .putExtra("locationId", resultLoc)
            )
            finish()
        } catch (t: Throwable) {
            Toast.makeText(this, "Bad response: ${t.message}", Toast.LENGTH_SHORT).show()
        }
    }
}
