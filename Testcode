void Firmware::updateBoard(quint32 destination, MEM_MEMORY_TYPE memoryType, QString binPath)
{
    updateComplete[destination] = false;
    updateSuccessful[destination] = false;

    QString board = boardsList[destination];
    GN2_Address addressForUpdate = GN2A_MCB;
    QString serverBoard;

    RPCA_Plant* rp = RPCA_Plant::getInstance();
    if ((!rp->isConnectedTo(GN2A_MCB)) && (destination == GN2A_ATLAS))
    {
        addressForUpdate = GN2A_ATLAS;
    }

    serverBoard = boardsList[addressForUpdate];

    ProLog().i(MODULE_NAME, "Firmware upgrade started on " + board.toStdString());

    QString somFileName = "N/A";
    bool toggleBankOnCurrentBoard = false;

    if (MEM_MEMORY_TYPE_INTERNAL_FLASH == memoryType)
    {
        if (GN2A_SOM == destination)
        {
            // ---- Find SOMApp tarball from BAS ----
            QRegularExpression tarRx("dynamoSOMApp.*\\.tar\\.gz\\.enc"); // safer regex
            int32_t indexOfTarBinary = binariesFound.indexOf(tarRx);

            bool tarFound = (indexOfTarBinary > -1);
            bool decryptFound = binariesFound.contains("decrypt");

            // Default: no automatic decrypt in this "two-process" approach
            m_sendDecryptAfterSOMApp = false;

            if (m_decryptOnlyMode)
            {
                // Process 2: decrypt only
                if (!decryptFound)
                {
                    ProLog().w(MODULE_NAME, "Decrypt-only mode enabled but 'decrypt' not found in BAS");
                    onBoardUpgraded(nullptr, destination, false);
                    return;
                }

                somFileName = "decrypt";
                binPath.append("/");
                binPath.append("decrypt");
            }
            else
            {
                // Process 1: SOMApp tarball only
                if (!tarFound)
                {
                    // fallback to original behavior if tar not present
                    binPath.append("/");
                    binPath.append(internalBinaries[destination]);
                    somFileName = internalBinaries[destination];
                }
                else
                {
                    somFileName = binariesFound.at(indexOfTarBinary);
                    binPath.append("/");
                    binPath.append(somFileName);

                    // OPTIONAL: store decrypt info for later, but DON'T auto start it
                    // (Two-process approach means you run decrypt in second call.)
                    if (decryptFound)
                    {
                        m_decryptPath = binPath;
                        m_decryptPath.replace(somFileName, "decrypt");
                        m_decryptMemType = memoryType;
                        m_decryptAddressForUpdate = addressForUpdate;
                        m_decryptServerBoard = serverBoard;

                        // keep false for true 2-process
                        m_sendDecryptAfterSOMApp = false;
                    }
                }
            }

            toggleBankOnCurrentBoard = false;
        }
        else
        {
            // non-SOM internal flash (unchanged)
            binPath.append("/");
            binPath.append(internalBinaries[destination]);
        }
    }
    else if (MEM_MEMORY_TYPE_EXTERNAL_FLASH0 == memoryType)
    {
        toggleBankOnCurrentBoard = false;
        binPath.append("/");
        binPath.append(externalImages[destination]);
    }

    ProLog().i(MODULE_NAME, "Image path: " + binPath.toStdString());

    FirmwareUpdateCAN* fw = new FirmwareUpdateCAN();
    fw->setImageData(binPath);
    fw->onChangedSelectedServer(addressForUpdate, serverBoard, NULL);
    fw->setDestination(destination);

    // ---- SOM requires SendImageFileName ----
    if (GN2A_SOM == destination)
    {
        MEM_SendImageFileNameRequest req = MEM_SendImageFileNameRequest_init_zero;
        MEM_SendImageFileNameResponse rsp = MEM_SendImageFileNameResponse_init_zero;
        req.memoryType = memoryType;

        // SAFE COPY (null-terminated)
        memset(req.imageName, 0, sizeof(req.imageName));
        QByteArray n = somFileName.toUtf8();
        int copyLen = std::min((int)sizeof(req.imageName) - 1, (int)n.size());
        memcpy(req.imageName, n.constData(), copyLen);
        req.imageName[copyLen] = '\0';

        ProLog().i(MODULE_NAME, "Downloading " + std::string(req.imageName) + " to SOM");

        if (CMD_OK != MEM_SendImageFileName(GN2A_SOM, &req, &rsp))
        {
            ProLog().w(MODULE_NAME, "Could not send file info to " + board.toStdString());
            onBoardUpgraded(fw, destination, false);
            return;
        }
    }
    else
    {
        if (!fw->validateImage(memoryType, false)) // do not check board version
        {
            ProLog().w(MODULE_NAME, "Image Verification failed on " + board.toStdString());
            onBoardUpgraded(fw, destination, false);
            return;
        }
    }

    connect(fw, &FirmwareUpdateCAN::imageUploadCompleted, this, &Firmware::onBoardUpgraded);
    connect(fw, &FirmwareUpdateCAN::errorNotification, this, &Firmware::onObservedError);
    connect(fw, &FirmwareUpdateCAN::infoNotification, this, &Firmware::onObservedInfo);
    connect(fw, &FirmwareUpdateCAN::progressObserved, this, &Firmware::onObservedProgress);
    connect(fw, &FirmwareUpdateCAN::newProgressPhaseStarted, this, &Firmware::onPhaseChanged);
    connect(this, &Firmware::abortUpgrade, fw, &FirmwareUpdateCAN::abortUpgrade, Qt::DirectConnection);

    currentMemoryType = memoryType;
    fw->startUpdate(memoryType, toggleBankOnCurrentBoard);
}
