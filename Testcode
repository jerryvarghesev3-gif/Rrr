package com.connect.connection

import android.content.Intent
import android.net.Uri
import android.os.Bundle
import android.view.View
import android.widget.*
import androidx.appcompat.app.AppCompatActivity
import org.eclipse.paho.android.service.MqttAndroidClient
import org.eclipse.paho.client.mqttv3.*
import org.json.JSONObject

class SummaryBActivity : AppCompatActivity() {

    // ---- UI (IDs must exist in your existing activity_summary_b.xml) ----
    private lateinit var txtGateway: TextView
    private lateinit var txtBed: TextView
    private lateinit var txtLocation: TextView
    private lateinit var txtInfo: TextView
    private lateinit var imgPreview: ImageView
    private lateinit var btnRescan: Button
    private lateinit var btnCancel: Button
    private lateinit var btnContinue: Button
    private lateinit var progress: ProgressBar

    // ---- Data from BActivity ----
    private var gatewayId = ""
    private var bedId = ""
    private var locationId = ""
    private var imageUri: Uri? = null

    // ---- MQTT ----
    private val mqtt: MqttAndroidClient?
        get() = MqttHolder.client  // <- change if your holder has a different accessor

    private var responseTopic: String? = null
    private var lastTxnId = 0

    // Empty callback used to clear our temporary one onDestroy
    private val NO_OP_CALLBACK = object : MqttCallbackExtended {
        override fun connectComplete(reconnect: Boolean, serverURI: String?) {}
        override fun connectionLost(cause: Throwable?) {}
        override fun messageArrived(topic: String?, message: MqttMessage?) {}
        override fun deliveryComplete(token: IMqttDeliveryToken?) {}
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_summary_b)

        // Bind UI
        txtGateway  = findViewById(R.id.txtGatewayB)
        txtBed      = findViewById(R.id.txtBedB)
        txtLocation = findViewById(R.id.txtLocationB)
        txtInfo     = findViewById(R.id.txtInfoB)
        imgPreview  = findViewById(R.id.imgPreviewB)
        btnRescan   = findViewById(R.id.btnRescanB)
        btnCancel   = findViewById(R.id.btnCancelB)
        btnContinue = findViewById(R.id.btnContinueB)
        progress    = findViewById(R.id.progressB)

        // Read extras (PUT and GET must use the same keys!)
        gatewayId  = intent.getStringExtra(BActivity.EXTRA_GATEWAY).orEmpty()
        bedId      = intent.getStringExtra(BActivity.EXTRA_BED).orEmpty()
        locationId = intent.getStringExtra(BActivity.EXTRA_LOCATION).orEmpty()
        intent.getStringExtra(BActivity.EXTRA_IMAGE_URI)?.let { imageUri = Uri.parse(it) }

        // Show
        txtGateway.text  = "Gateway: $gatewayId"
        txtBed.text      = "Bed ID: $bedId"
        txtLocation.text = "Location ID: $locationId"
        imageUri?.let { imgPreview.setImageURI(it) }

        // Buttons
        btnRescan.setOnClickListener { finish() }   // back to BActivity to rescan
        btnCancel.setOnClickListener { finish() }

        btnContinue.setOnClickListener {
            if (gatewayId.isBlank() || bedId.isBlank() || locationId.isBlank()) {
                Toast.makeText(this, "Missing IDs", Toast.LENGTH_SHORT).show()
                return@setOnClickListener
            }
            subscribeForReplyAndSend()
        }
    }

    // ---------- Topics ----------
    private fun reqTopic(gw: String)  = "gw/$gw/req/set_location"
    private fun respTopic(bed: String) = "bed/$bed/resp/set_location"

    // ---------- Publish flow (subscribe -> set callback -> publish) ----------
    private fun subscribeForReplyAndSend(force: Boolean = false) {
        val c = mqtt
        if (c == null || !c.isConnected) {
            setBusy(false, "MQTT not connected")
            return
        }
        setBusy(true, "Preparing…")

        val rTopic = respTopic(bedId)
        responseTopic = rTopic

        // 1) Subscribe for the response
        c.subscribe(rTopic, 1, null, object : IMqttActionListener {
            override fun onSuccess(asyncActionToken: IMqttToken?) {
                // 2) Install a filtering callback
                c.setCallback(object : MqttCallbackExtended {
                    override fun connectComplete(reconnect: Boolean, serverURI: String?) {}
                    override fun connectionLost(cause: Throwable?) {}

                    override fun messageArrived(topic: String?, message: MqttMessage?) {
                        if (topic == responseTopic) {
                            val payload = message?.toString().orEmpty()
                            runOnUiThread { handleSetLocationResponse(payload) }
                        }
                    }

                    override fun deliveryComplete(token: IMqttDeliveryToken?) {}
                })
                // 3) Publish the request
                publishSetLocation(force)
            }
            override fun onFailure(asyncActionToken: IMqttToken?, exception: Throwable?) {
                setBusy(false, "Subscribe failed: ${exception?.message}")
            }
        })
    }

    private fun publishSetLocation(force: Boolean) {
        val c = mqtt
        if (c == null || !c.isConnected) {
            setBusy(false, "MQTT not connected")
            return
        }
        val topic = reqTopic(gatewayId)
        lastTxnId += 1

        // Use field names your server expects (many of your earlier screenshots showed snake_case)
        val data = JSONObject().apply {
            put("bed_id", bedId)
            put("location_id", locationId)
            put("force", force)
        }
        val req = JSONObject().apply {
            put("command", "set_location")
            put("data", data)
            put("reply_to", respTopic(bedId))
            put("transaction_id", lastTxnId)
        }
        val payload = req.toString().toByteArray(Charsets.UTF_8)

        setBusy(true, "Sending set_location…")
        c.publish(topic, payload, 1, false, null, object : IMqttActionListener {
            override fun onSuccess(asyncActionToken: IMqttToken?) {
                setBusy(true, "Waiting for response…")
            }
            override fun onFailure(asyncActionToken: IMqttToken?, exception: Throwable?) {
                setBusy(false, "Publish failed: ${exception?.message}")
            }
        })
    }

    // ---------- Handle reply JSON ----------
    private fun handleSetLocationResponse(json: String) {
        try {
            val root = JSONObject(json)
            val status = root.optInt("status", -1)

            // Some firmwares echo back "data": { "locationId": "..." } in camelCase
            val locFromResp = root.optJSONObject("data")?.let { d ->
                d.optString("locationId", d.optString("location_id", ""))
            }
            val finalLoc = if (!locFromResp.isNullOrBlank()) locFromResp else locationId

            // Navigate to final SummaryActivity (your existing end screen)
            val i = Intent(this, SummaryActivity::class.java).apply {
                putExtra("gatewayId", gatewayId)
                putExtra("bedId", bedId)
                putExtra("locationId", finalLoc)
                putExtra("status", status)
            }
            startActivity(i)
            finish()
        } catch (t: Throwable) {
            setBusy(false, "Response parse error: ${t.message}")
        }
    }

    // ---------- UI helpers ----------
    private fun setBusy(busy: Boolean, message: String) {
        txtInfo.text = message
        progress.visibility = if (busy) View.VISIBLE else View.GONE
        btnContinue.isEnabled = !busy
        btnRescan.isEnabled = !busy
        btnCancel.isEnabled = !busy
    }

    override fun onDestroy() {
        super.onDestroy()
        try {
            val c = mqtt
            responseTopic?.let { c?.unsubscribe(it) }
            c?.setCallback(NO_OP_CALLBACK)
        } catch (_: Exception) { }
    }
}










package com.connect.connection

import android.content.Intent
import android.net.Uri
import android.os.Bundle
import android.util.Log
import android.widget.Button
import android.widget.ImageView
import android.widget.TextView
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import androidx.camera.core.*
import androidx.camera.lifecycle.ProcessCameraProvider
import androidx.core.content.ContextCompat
import java.io.File
import java.text.SimpleDateFormat
import java.util.*
import java.util.concurrent.ExecutorService
import java.util.concurrent.Executors

class BActivity : AppCompatActivity() {

    companion object {
        const val EXTRA_GATEWAY   = "gatewayId"
        const val EXTRA_BED       = "bedId"
        const val EXTRA_LOCATION  = "locationId"
        const val EXTRA_IMAGE_URI = "imageUri"
    }

    private lateinit var previewView: androidx.camera.view.PreviewView
    private lateinit var txtScanValueB: TextView
    private lateinit var imgPreviewB: ImageView
    private lateinit var btnContinueB: Button

    private var cameraExecutor: ExecutorService? = null
    private var imageCapture: ImageCapture? = null

    private var gatewayId: String = ""
    private var bedId: String = ""
    private var locationId: String = ""
    private var imageUri: Uri? = null

    private var lastDecoded: String? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_qrb)

        previewView    = findViewById(R.id.previewViewB)
        txtScanValueB  = findViewById(R.id.txtScanValueB)
        imgPreviewB    = findViewById(R.id.imgPreviewB)
        btnContinueB   = findViewById(R.id.btnContinueB)

        btnContinueB.isEnabled = false

        gatewayId = intent.getStringExtra(EXTRA_GATEWAY).orEmpty()
        bedId     = intent.getStringExtra(EXTRA_BED).orEmpty()

        cameraExecutor = Executors.newSingleThreadExecutor()
        startCamera()

        btnContinueB.setOnClickListener {
            if (locationId.isBlank()) {
                Toast.makeText(this, "Scan a QR first", Toast.LENGTH_SHORT).show()
                return@setOnClickListener
            }
            val i = Intent(this, SummaryBActivity::class.java).apply {
                putExtra(EXTRA_GATEWAY, gatewayId)
                putExtra(EXTRA_BED, bedId)
                putExtra(EXTRA_LOCATION, locationId)
                imageUri?.let { putExtra(EXTRA_IMAGE_URI, it.toString()) }
            }
            startActivity(i)
        }
    }

    // ---------------- Camera + Analyzer ----------------
    private fun startCamera() {
        val cameraProviderFuture = ProcessCameraProvider.getInstance(this)
        cameraProviderFuture.addListener({
            val cameraProvider = cameraProviderFuture.get()

            val preview = Preview.Builder().build().also {
                it.setSurfaceProvider(previewView.surfaceProvider)
            }

            imageCapture = ImageCapture.Builder().build()

            val analyzer = ImageAnalysis.Builder()
                .setBackpressureStrategy(ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)
                .build()
                .also {
                    it.setAnalyzer(cameraExecutor!!, QRAnalyzer { qrText ->
                        runOnUiThread {
                            if (lastDecoded != qrText) {
                                lastDecoded = qrText
                                onLocationDecoded(qrText)
                            }
                        }
                    })
                }

            try {
                cameraProvider.unbindAll()
                cameraProvider.bindToLifecycle(
                    this, CameraSelector.DEFAULT_BACK_CAMERA, preview, imageCapture, analyzer
                )
            } catch (exc: Exception) {
                Log.e("BActivity", "Camera binding failed", exc)
            }

        }, ContextCompat.getMainExecutor(this))
    }

    // Called when QR decoded
    private fun onLocationDecoded(decoded: String) {
        locationId = decoded.trim()
        txtScanValueB.text = locationId
        capturePhoto()
    }

    private fun capturePhoto() {
        val imageCapture = imageCapture ?: return

        val photoFile = File(
            externalMediaDirs.first(),
            SimpleDateFormat("yyyyMMdd_HHmmss", Locale.US).format(System.currentTimeMillis()) + ".jpg"
        )
        val outputOptions = ImageCapture.OutputFileOptions.Builder(photoFile).build()

        imageCapture.takePicture(
            outputOptions,
            ContextCompat.getMainExecutor(this),
            object : ImageCapture.OnImageSavedCallback {
                override fun onError(exc: ImageCaptureException) {
                    Log.e("BActivity", "Photo capture failed: ${exc.message}", exc)
                }

                override fun onImageSaved(output: ImageCapture.OutputFileResults) {
                    imageUri = Uri.fromFile(photoFile)
                    imgPreviewB.setImageURI(imageUri)
                    btnContinueB.isEnabled = true
                }
            }
        )
    }

    override fun onDestroy() {
        super.onDestroy()
        cameraExecutor?.shutdown()
    }
}





