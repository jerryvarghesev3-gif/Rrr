if (MEM_MEMORY_TYPE_INTERNAL_FLASH == memoryType)
{
    if (GN2A_SOM == destination)
    {
        // Keep your existing folder scan result list
        const QString baseDir = binPath; // binPath is folder in your code
        // binariesFound is your existing QStringList for that folder

        // Find SOM tar
        QRegularExpression tarRx("^dynamoSOMApp.*\\.tar\\.gz\\.enc$");
        int indexOfTarBinary = binariesFound.indexOf(tarRx);
        if (indexOfTarBinary < 0)
        {
            ProLog().w(MODULE_NAME, QString("SOM tar not found in: %1").arg(baseDir).toStdString());
            onBoardUpgraded(nullptr, destination, false);
            return;
        }
        const QString somTarName = binariesFound.at(indexOfTarBinary);
        const QString somTarPath = baseDir + "/" + somTarName;

        // Find decrypt (optional)
        QRegularExpression decryptRx("^decrypt(\\..+)?$");
        int indexOfDecrypt = binariesFound.indexOf(decryptRx);

        const bool hasDecrypt = (indexOfDecrypt >= 0);
        const QString decryptName = hasDecrypt ? binariesFound.at(indexOfDecrypt) : QString();
        const QString decryptPath = hasDecrypt ? (baseDir + "/" + decryptName) : QString();

        // ---------- helper: safely send filename to MEM ----------
        auto sendImageName = [&](const QString& fileName) -> bool
        {
            MEM_SendImageFileNameRequest req = MEM_SendImageFileNameRequest_init_zero;
            MEM_SendImageFileNameResponse rsp = MEM_SendImageFileNameResponse_init_zero;
            req.memoryType = memoryType;

            const QByteArray nameBytes = fileName.toUtf8();
            memset(req.imageName, 0, sizeof(req.imageName));

            // avoid std::min qsizetype/int mismatch
            const int maxLen = int(sizeof(req.imageName)) - 1; // keep null terminator
            const int copyLen = (nameBytes.size() < maxLen) ? nameBytes.size() : maxLen;
            memcpy(req.imageName, nameBytes.constData(), size_t(copyLen));

            return (CMD_OK == MEM_SendImageFileName(GN2A_SOM, &req, &rsp));
        };

        // ---------- helper: start one upload ----------
        auto startUpload = [&](FirmwareUpdateCAN* fw, const QString& filePath, const QString& fileName)
        {
            fw->setImageData(filePath);
            fw->onChangedSelectedServer(addressForUpdate, serverBoard, NULL);
            fw->setDestination(destination);

            ProLog().i(MODULE_NAME, QString("Downloading %1 to SOM").arg(fileName).toStdString());

            if (!sendImageName(fileName))
            {
                ProLog().w(MODULE_NAME, QString("Could not send file info for %1").arg(fileName).toStdString());
                onBoardUpgraded(fw, destination, false);
                return;
            }

            fw->startUpdate(memoryType, false);
        };

        // ---------- SEQUENCE ----------
        // If decrypt exists: upload decrypt FIRST, then on success upload TAR.
        // If no decrypt: just upload TAR (old behavior).

        if (hasDecrypt)
        {
            FirmwareUpdateCAN* fwDecrypt = new FirmwareUpdateCAN();

            // When decrypt upload completes successfully -> start TAR upload
            connect(
                fwDecrypt,
                &FirmwareUpdateCAN::imageUploadCompleted,
                this,
                [=](unsigned int /*dest*/, const QString& /*msg*/, bool ok)
                {
                    // If decrypt upload failed, stop here (tar must not start)
                    if (!ok)
                    {
                        onBoardUpgraded(fwDecrypt, destination, false);
                        return;
                    }

                    // Start TAR upload second
                    FirmwareUpdateCAN* fwTar = new FirmwareUpdateCAN();

                    // IMPORTANT: let TAR upload completion drive your normal flow (onBoardUpgraded)
                    connect(
                        fwTar,
                        &FirmwareUpdateCAN::imageUploadCompleted,
                        this,
                        [=](unsigned int /*dest2*/, const QString& /*msg2*/, bool ok2)
                        {
                            onBoardUpgraded(fwTar, destination, ok2);
                        },
                        Qt::QueuedConnection);

                    connect(fwTar, &FirmwareUpdateCAN::errorNotification, this, &Firmware::onObservedError);
                    connect(fwTar, &FirmwareUpdateCAN::infoNotification,  this, &Firmware::onObservedInfo);
                    connect(fwTar, &FirmwareUpdateCAN::progressObserved,  this, &Firmware::onObservedProgress);
                    connect(fwTar, &FirmwareUpdateCAN::newProgressPhaseStarted, this, &Firmware::onPhaseChanged);
                    connect(this, &Firmware::abortUpgrade, fwTar, &FirmwareUpdateCAN::abortUpgrade, Qt::DirectConnection);

                    currentMemoryType = memoryType;
                    startUpload(fwTar, somTarPath, somTarName);
                },
                Qt::QueuedConnection);

            // Keep your existing handlers for decrypt as well (optional but good)
            connect(fwDecrypt, &FirmwareUpdateCAN::errorNotification, this, &Firmware::onObservedError);
            connect(fwDecrypt, &FirmwareUpdateCAN::infoNotification,  this, &Firmware::onObservedInfo);
            connect(fwDecrypt, &FirmwareUpdateCAN::progressObserved,  this, &Firmware::onObservedProgress);
            connect(fwDecrypt, &FirmwareUpdateCAN::newProgressPhaseStarted, this, &Firmware::onPhaseChanged);
            connect(this, &Firmware::abortUpgrade, fwDecrypt, &FirmwareUpdateCAN::abortUpgrade, Qt::DirectConnection);

            currentMemoryType = memoryType;
            startUpload(fwDecrypt, decryptPath, decryptName);

            return; // ✅ important: don’t fall through into old SOM code
        }

        // No decrypt -> old behavior, TAR only
        FirmwareUpdateCAN* fwTar = new FirmwareUpdateCAN();

        connect(
            fwTar,
            &FirmwareUpdateCAN::imageUploadCompleted,
            this,
            [=](unsigned int /*dest*/, const QString& /*msg*/, bool ok)
            {
                onBoardUpgraded(fwTar, destination, ok);
            },
            Qt::QueuedConnection);

        connect(fwTar, &FirmwareUpdateCAN::errorNotification, this, &Firmware::onObservedError);
        connect(fwTar, &FirmwareUpdateCAN::infoNotification,  this, &Firmware::onObservedInfo);
        connect(fwTar, &FirmwareUpdateCAN::progressObserved,  this, &Firmware::onObservedProgress);
        connect(fwTar, &FirmwareUpdateCAN::newProgressPhaseStarted, this, &Firmware::onPhaseChanged);
        connect(this, &Firmware::abortUpgrade, fwTar, &FirmwareUpdateCAN::abortUpgrade, Qt::DirectConnection);

        currentMemoryType = memoryType;
        startUpload(fwTar, somTarPath, somTarName);
        return;
    }

    // ✅ everything below remains your existing logic for other boards (UNCHANGED)
}











if (MEM_MEMORY_TYPE_INTERNAL_FLASH == memoryType)
{
    if (GN2A_SOM == destination)
    {
        // binPath is a folder path
        const QString baseDir = binPath;

        // find files in extracted folder list
        QRegularExpression tarRx("^dynamoSOMApp.*\\.tar\\.gz\\.enc$");
        int tarIdx = binariesFound.indexOf(tarRx);

        QRegularExpression decryptRx("^decrypt(\\..+)?$");
        int decIdx = binariesFound.indexOf(decryptRx);

        if (tarIdx < 0)
        {
            ProLog().w(MODULE_NAME, QString("SOM tar not found in %1").arg(baseDir).toStdString());
            onBoardUpgraded(nullptr, destination, false);
            return;
        }

        const QString tarName = binariesFound.at(tarIdx);
        const QString tarPath = baseDir + "/" + tarName;

        QString decName;
        QString decPath;
        const bool hasDecrypt = (decIdx >= 0);
        if (hasDecrypt)
        {
            decName = binariesFound.at(decIdx);
            decPath = baseDir + "/" + decName;
        }

        auto sendFileInfoAndStart = [&](FirmwareUpdateCAN* fwObj,
                                        const QString& fileName,
                                        const QString& filePath,
                                        std::function<void(FirmwareUpdateCAN*, bool)> onDone)
        {
            fwObj->setImageData(filePath);
            fwObj->onChangedSelectedServer(addressForUpdate, serverBoard, NULL);
            fwObj->setDestination(destination);

            MEM_SendImageFileNameRequest req = MEM_SendImageFileNameRequest_init_zero;
            MEM_SendImageFileNameResponse rsp = MEM_SendImageFileNameResponse_init_zero;
            req.memoryType = memoryType;

            const QByteArray nameBytes = fileName.toUtf8();
            memset(req.imageName, 0, sizeof(req.imageName));
            const int copyLen = qMin(nameBytes.size(), (int)sizeof(req.imageName) - 1);
            memcpy(req.imageName, nameBytes.constData(), copyLen);

            ProLog().i(MODULE_NAME, QString("Downloading %1 to SOM").arg(fileName).toStdString());

            if (CMD_OK != MEM_SendImageFileName(GN2A_SOM, &req, &rsp))
            {
                ProLog().w(MODULE_NAME, QString("Could not send file info for %1").arg(fileName).toStdString());
                onDone(fwObj, false);
                return;
            }

            // IMPORTANT: signal signature is (FirmwareUpdateCAN*, quint32, bool)
            connect(fwObj, &FirmwareUpdateCAN::imageUploadCompleted,
                    this,
                    [=](FirmwareUpdateCAN* fw, quint32 /*board*/, bool ok)
                    {
                        onDone(fw, ok);
                    },
                    Qt::QueuedConnection);

            // Keep your usual status hooks
            connect(fwObj, &FirmwareUpdateCAN::errorNotification, this, &Firmware::onObservedError);
            connect(fwObj, &FirmwareUpdateCAN::infoNotification,  this, &Firmware::onObservedInfo);
            connect(fwObj, &FirmwareUpdateCAN::progressObserved,  this, &Firmware::onObservedProgress);
            connect(fwObj, &FirmwareUpdateCAN::newProgressPhaseStarted, this, &Firmware::onPhaseChanged);

            currentMemoryType = memoryType;
            fwObj->startUpdate(memoryType, false);
        };

        // ✅ SEQUENCE FIX:
        // 1) decrypt upload FIRST (if present)
        // 2) tar upload SECOND (last) so it is not wiped by decrypt transfer cleanup

        if (hasDecrypt)
        {
            FirmwareUpdateCAN* fwDecrypt = new FirmwareUpdateCAN();

            sendFileInfoAndStart(
                fwDecrypt,
                decName,
                decPath,
                [=](FirmwareUpdateCAN* fw, bool ok)
                {
                    if (!ok)
                    {
                        onBoardUpgraded(fw, destination, false);
                        return;
                    }

                    // now upload tar LAST
                    FirmwareUpdateCAN* fwTar = new FirmwareUpdateCAN();
                    sendFileInfoAndStart(
                        fwTar,
                        tarName,
                        tarPath,
                        [=](FirmwareUpdateCAN* fw2, bool ok2)
                        {
                            // tar completion drives normal flow
                            onBoardUpgraded(fw2, destination, ok2);

                            // if you have your existing "start next" callback, trigger it only after tar succeeds
                            if (ok2 && onSuccessStartNext)
                                onSuccessStartNext();
                        });
                });
        }
        else
        {
            // no decrypt -> just upload tar as before
            FirmwareUpdateCAN* fwTar = new FirmwareUpdateCAN();
            sendFileInfoAndStart(
                fwTar,
                tarName,
                tarPath,
                [=](FirmwareUpdateCAN* fw2, bool ok2)
                {
                    onBoardUpgraded(fw2, destination, ok2);
                    if (ok2 && onSuccessStartNext)
                        onSuccessStartNext();
                });
        }

        return; // ✅ exit only SOM special handling; function continues for other boards otherwise
    }

    // ✅ everything below remains yours (other boards logic)
}
