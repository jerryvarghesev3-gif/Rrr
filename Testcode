package com.connect.connection

import android.content.Intent
import android.net.Uri
import android.os.Bundle
import android.view.View
import android.widget.*
import androidx.appcompat.app.AppCompatActivity
import info.mqtt.android.service.MqttAndroidClient
import org.eclipse.paho.client.mqttv3.IMqttActionListener
import org.eclipse.paho.client.mqttv3.IMqttDeliveryToken
import org.eclipse.paho.client.mqttv3.IMqttToken
import org.eclipse.paho.client.mqttv3.MqttCallbackExtended
import org.eclipse.paho.client.mqttv3.MqttMessage
import org.json.JSONObject

class SummaryBActivity : AppCompatActivity() {

    // ---- UI ----
    private lateinit var txtGateway: TextView
    private lateinit var txtBed: TextView
    private lateinit var txtLocation: TextView
    private lateinit var txtInfo: TextView
    private lateinit var imgPreview: ImageView
    private lateinit var btnRescan: Button
    private lateinit var btnCancel: Button
    private lateinit var btnContinue: Button
    private lateinit var progress: ProgressBar

    // ---- Data from BActivity ----
    private var gatewayId = ""
    private var bedId = ""
    private var locationId = ""
    private var imageUri: Uri? = null

    // ---- MQTT ----
    private val mqtt: MqttAndroidClient? get() = MqttHolder.client  // use your existing singleton
    private var txnId = 0
    private var subscribed = false

    private val mqttCallback = object : MqttCallbackExtended {
        override fun connectComplete(reconnect: Boolean, serverURI: String?) {}
        override fun connectionLost(cause: Throwable?) {}

        override fun messageArrived(topic: String?, message: MqttMessage?) {
            val body = message?.toString().orEmpty()
            if (topic == respTopicBed(bedId) || topic == respTopicGw(gatewayId)) {
                handleSetLocationResponse(body)
            }
        }

        override fun deliveryComplete(token: IMqttDeliveryToken?) {}
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_summary_b)

        // Bind UI
        txtGateway  = findViewById(R.id.txtGatewayB)
        txtBed      = findViewById(R.id.txtBedB)
        txtLocation = findViewById(R.id.txtLocationB)
        txtInfo     = findViewById(R.id.txtInfoB)
        imgPreview  = findViewById(R.id.imgPreviewB)
        btnRescan   = findViewById(R.id.btnRescanB)
        btnCancel   = findViewById(R.id.btnCancelB)
        btnContinue = findViewById(R.id.btnContinueB)
        progress    = findViewById(R.id.progressB)

        // Read extras from BActivity (keys defined there)
        gatewayId  = intent.getStringExtra(BActivity.EXTRA_GATEWAY).orEmpty()
        bedId      = intent.getStringExtra(BActivity.EXTRA_BED).orEmpty()
        locationId = intent.getStringExtra(BActivity.EXTRA_LOCATION).orEmpty()
        intent.getStringExtra(BActivity.EXTRA_IMAGE_URI)?.let { imageUri = Uri.parse(it) }

        // Show
        txtGateway.text  = "Gateway: $gatewayId"
        txtBed.text      = "Bed ID: $bedId"
        txtLocation.text = "Location ID: $locationId"
        imageUri?.let { imgPreview.setImageURI(it) }

        // Buttons
        btnRescan.setOnClickListener { finish() }           // back to BActivity to scan again
        btnCancel.setOnClickListener { finishAffinity() }   // close flow
        btnContinue.setOnClickListener { onContinue() }
    }

    // ---- Topics ----
    private fun reqTopicGw(gw: String)  = "gw/$gw/req/set_location"
    private fun respTopicBed(bed: String) = "bed/$bed/resp/set_location"
    private fun respTopicGw(gw: String) = "gw/$gw/resp/set_location"

    // ---- Continue flow: subscribe -> publish ----
    private fun onContinue() {
        if (gatewayId.isBlank() || bedId.isBlank() || locationId.isBlank()) {
            Toast.makeText(this, "Missing IDs", Toast.LENGTH_SHORT).show()
            return
        }
        val c = mqtt ?: run {
            Toast.makeText(this, "MQTT not connected", Toast.LENGTH_SHORT).show()
            return
        }
        setBusy(true, "Preparing…")

        // Set callback once
        c.setCallback(mqttCallback)

        // Subscribe to both possible reply topics (some firmwares use bed/, some gw/)
        val bedResp = respTopicBed(bedId)
        val gwResp  = respTopicGw(gatewayId)

        // Subscribe both, then publish
        c.subscribe(bedResp, 1, null, object : IMqttActionListener {
            override fun onSuccess(asyncActionToken: IMqttToken?) {
                c.subscribe(gwResp, 1, null, object : IMqttActionListener {
                    override fun onSuccess(asyncActionToken: IMqttToken?) {
                        subscribed = true
                        publishSetLocation()
                    }
                    override fun onFailure(asyncActionToken: IMqttToken?, exception: Throwable?) {
                        setBusy(false, "Subscribe failed: ${exception?.message}")
                    }
                })
            }
            override fun onFailure(asyncActionToken: IMqttToken?, exception: Throwable?) {
                setBusy(false, "Subscribe failed: ${exception?.message}")
            }
        })
    }

    private fun publishSetLocation(force: Boolean = true) {
        val c = mqtt ?: return
        txnId += 1

        // Build JSON according to your server’s schema (snake_case seen in prior screenshots)
        val data = JSONObject().apply {
            put("bed_id", bedId)
            put("location_id", locationId)
            put("force", force)
        }
        val req = JSONObject().apply {
            put("command", "set_location")
            put("data", data)
            put("reply_to", respTopicBed(bedId)) // safe default; device may also reply on gw/
            put("transaction_id", txnId)
        }
        val payload = req.toString().toByteArray(Charsets.UTF_8)

        setBusy(true, "Sending set_location…")
        c.publish(reqTopicGw(gatewayId), payload, 1, false, null, object : IMqttActionListener {
            override fun onSuccess(asyncActionToken: IMqttToken?) {
                setBusy(true, "Waiting for response…")
            }
            override fun onFailure(asyncActionToken: IMqttToken?, exception: Throwable?) {
                setBusy(false, "Publish failed: ${exception?.message}")
            }
        })
    }

    // ---- Handle reply ----
    private fun handleSetLocationResponse(json: String) {
        try {
            val root = JSONObject(json)
            val status = root.optInt("status", -1)

            // Optional: extract echoed location for display
            val echoedLoc = root.optJSONObject("data")?.let { d ->
                d.optString("location_id", d.optString("locationId", ""))
            }
            val finalLoc = if (!echoedLoc.isNullOrBlank()) echoedLoc else locationId

            // Go to your final SummaryActivity (tick/cross screen)
            val intent = Intent(this, SummaryActivity::class.java).apply {
                putExtra("gatewayId", gatewayId)
                putExtra("bedId", bedId)
                putExtra("locationId", finalLoc)
                putExtra("status", status)
            }
            startActivity(intent)
            finish()

        } catch (t: Throwable) {
            setBusy(false, "Response parse error: ${t.message}")
        }
    }

    // ---- UI helpers ----
    private fun setBusy(busy: Boolean, message: String) {
        txtInfo.text = message
        progress.visibility = if (busy) View.VISIBLE else View.GONE
        btnContinue.isEnabled = !busy
        btnRescan.isEnabled = !busy
        btnCancel.isEnabled = !busy
    }

    override fun onDestroy() {
        super.onDestroy()
        try {
            val c = mqtt
            if (c != null && c.isConnected && subscribed) {
                c.unsubscribe(respTopicBed(bedId))
                c.unsubscribe(respTopicGw(gatewayId))
            }
            c?.setCallback(null)
        } catch (_: Exception) { }
    }
}





package com.connect.connection

import android.Manifest
import android.content.ContentValues
import android.content.Intent
import android.content.pm.PackageManager
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.provider.MediaStore
import android.widget.ImageView
import android.widget.TextView
import android.widget.Toast
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AppCompatActivity
import androidx.camera.core.*
import androidx.camera.lifecycle.ProcessCameraProvider
import androidx.camera.view.PreviewView
import androidx.core.content.ContextCompat
import com.google.mlkit.vision.barcode.Barcode
import com.google.mlkit.vision.barcode.BarcodeScannerOptions
import com.google.mlkit.vision.barcode.BarcodeScanning
import com.google.mlkit.vision.common.InputImage
import java.text.SimpleDateFormat
import java.util.Locale
import java.util.concurrent.ExecutorService
import java.util.concurrent.Executors

class BActivity : AppCompatActivity() {

    companion object {
        const val EXTRA_GATEWAY    = "gatewayId"
        const val EXTRA_BED        = "bedId"
        const val EXTRA_LOCATION   = "locationId"
        const val EXTRA_IMAGE_URI  = "imageUri"
    }

    private lateinit var previewView: PreviewView
    private lateinit var txtScanValueB: TextView
    private lateinit var imgPreviewB: ImageView

    private var cameraExecutor: ExecutorService? = null
    private var imageAnalysis: ImageAnalysis? = null
    private var imageCapture: ImageCapture? = null

    private var gatewayId = ""
    private var bedId = ""
    private var lastDecoded: String? = null
    private var takingPhoto = false

    private val requestCameraPerm =
        registerForActivityResult(ActivityResultContracts.RequestPermission()) { granted ->
            if (granted) startCamera() else finish()
        }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_qrb)  // keep your existing layout

        previewView   = findViewById(R.id.previewViewB)
        txtScanValueB = findViewById(R.id.txtScanValueB)
        imgPreviewB   = findViewById(R.id.imgPreviewB)

        gatewayId = intent.getStringExtra(EXTRA_GATEWAY).orEmpty()
        bedId     = intent.getStringExtra(EXTRA_BED).orEmpty()

        cameraExecutor = Executors.newSingleThreadExecutor()
        ensureCameraThenStart()
    }

    private fun ensureCameraThenStart() {
        if (ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA)
            == PackageManager.PERMISSION_GRANTED
        ) {
            startCamera()
        } else {
            requestCameraPerm.launch(Manifest.permission.CAMERA)
        }
    }

    // ---------- CameraX + MLKit ----------
    private fun startCamera() {
        val cameraProviderFuture = ProcessCameraProvider.getInstance(this)
        cameraProviderFuture.addListener({
            val cameraProvider = cameraProviderFuture.get()

            val preview = Preview.Builder().build().also {
                it.setSurfaceProvider(previewView.surfaceProvider)
            }

            imageCapture = ImageCapture.Builder()
                .setCaptureMode(ImageCapture.CAPTURE_MODE_MINIMIZE_LATENCY)
                .build()

            val scanner = BarcodeScanning.getClient(
                BarcodeScannerOptions.Builder()
                    .setBarcodeFormats(Barcode.FORMAT_QR_CODE)
                    .build()
            )

            imageAnalysis = ImageAnalysis.Builder()
                .setBackpressureStrategy(ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)
                .build().also { analysis ->
                    analysis.setAnalyzer(cameraExecutor!!) { imageProxy ->
                        val mediaImage = imageProxy.image
                        if (mediaImage != null) {
                            val image = InputImage.fromMediaImage(
                                mediaImage,
                                imageProxy.imageInfo.rotationDegrees
                            )
                            scanner.process(image)
                                .addOnSuccessListener { codes ->
                                    val text = codes.firstOrNull()?.rawValue
                                    if (!text.isNullOrBlank() && text != lastDecoded) {
                                        lastDecoded = text
                                        runOnUiThread { txtScanValueB.text = text }
                                        captureThenForward(text)
                                    }
                                }
                                .addOnCompleteListener { imageProxy.close() }
                        } else {
                            imageProxy.close()
                        }
                    }
                }

            cameraProvider.unbindAll()
            cameraProvider.bindToLifecycle(
                this,
                CameraSelector.DEFAULT_BACK_CAMERA,
                preview,
                imageCapture,
                imageAnalysis
            )
        }, ContextCompat.getMainExecutor(this))
    }

    private fun captureThenForward(locationId: String) {
        // prevent double triggers
        if (takingPhoto) return
        takingPhoto = true

        val cap = imageCapture ?: return forward(locationId, null)

        val name = "scan_${SimpleDateFormat("yyyyMMdd_HHmmss", Locale.US).format(System.currentTimeMillis())}.jpg"
        val contentValues = ContentValues().apply {
            put(MediaStore.MediaColumns.DISPLAY_NAME, name)
            put(MediaStore.MediaColumns.MIME_TYPE, "image/jpeg")
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                put(MediaStore.Images.Media.RELATIVE_PATH, "Pictures/ConnectScans")
            }
        }

        val output = ImageCapture.OutputFileOptions.Builder(
            contentResolver,
            MediaStore.Images.Media.EXTERNAL_CONTENT_URI,
            contentValues
        ).build()

        cap.takePicture(
            output,
            ContextCompat.getMainExecutor(this),
            object : ImageCapture.OnImageSavedCallback {
                override fun onImageSaved(result: ImageCapture.OutputFileResults) {
                    val uri = result.savedUri
                    imgPreviewB.setImageURI(uri)
                    forward(locationId, uri)
                }

                override fun onError(exception: ImageCaptureException) {
                    Toast.makeText(this@BActivity, "Photo failed: ${exception.message}", Toast.LENGTH_SHORT).show()
                    forward(locationId, null) // still go forward without photo
                }
            }
        )
    }

    private fun forward(locationId: String, photo: Uri?) {
        val i = Intent(this, SummaryBActivity::class.java).apply {
            putExtra(EXTRA_GATEWAY,  gatewayId)
            putExtra(EXTRA_BED,      bedId)
            putExtra(EXTRA_LOCATION, locationId)
            photo?.let { putExtra(EXTRA_IMAGE_URI, it.toString()) }
        }
        startActivity(i)
        finish() // leave scanner
    }

    override fun onDestroy() {
        super.onDestroy()
        cameraExecutor?.shutdown()
    }
}











package com.connect.connection

import android.Manifest
import android.content.Intent
import android.content.pm.PackageManager
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.widget.ImageView
import android.widget.TextView
import android.widget.Toast
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AppCompatActivity
import androidx.camera.core.*
import androidx.camera.lifecycle.ProcessCameraProvider
import androidx.camera.view.PreviewView
import androidx.core.content.ContextCompat
import com.google.mlkit.vision.barcode.BarcodeScanning
import com.google.mlkit.vision.common.InputImage
import java.io.File
import java.text.SimpleDateFormat
import java.util.Locale
import java.util.concurrent.ExecutorService
import java.util.concurrent.Executors
import java.util.concurrent.atomic.AtomicBoolean

class BActivity : AppCompatActivity() {

    companion object {
        const val EXTRA_GATEWAY   = "gatewayId"
        const val EXTRA_BED       = "bedId"
        const val EXTRA_LOCATION  = "locationId"
        const val EXTRA_IMAGE_URI = "imageUri"
    }

    // UI (must exist in activity_qrb.xml)
    private lateinit var previewViewB: PreviewView
    private lateinit var txtScanValueB: TextView
    private lateinit var imgPreviewB: ImageView

    // CameraX
    private lateinit var cameraExecutor: ExecutorService
    private var imageAnalysis: ImageAnalysis? = null
    private var imageCapture: ImageCapture? = null
    private val analyzing = AtomicBoolean(false)

    // Inputs from A
    private var gatewayId = ""
    private var bedId     = ""

    // Values we produce
    private var locationId = ""
    private var imageUri: Uri? = null

    // Flow guards
    private var navigated = false
    private var lastDecoded: String? = null

    // Permission launcher
    private val requestCameraPerm =
        registerForActivityResult(ActivityResultContracts.RequestPermission()) { granted ->
            if (granted) startCamera() else {
                Toast.makeText(this, "Camera permission required", Toast.LENGTH_LONG).show()
                finish()
            }
        }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_qrb)

        previewViewB   = findViewById(R.id.previewViewB)
        txtScanValueB  = findViewById(R.id.txtScanValueB)
        imgPreviewB    = findViewById(R.id.imgPreviewB)

        // Read values from A
        gatewayId = intent.getStringExtra(EXTRA_GATEWAY).orEmpty()
        bedId     = intent.getStringExtra(EXTRA_BED).orEmpty()

        cameraExecutor = Executors.newSingleThreadExecutor()

        // Ask for camera permission if needed
        if (ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA)
            == PackageManager.PERMISSION_GRANTED
        ) {
            startCamera()
        } else {
            requestCameraPerm.launch(Manifest.permission.CAMERA)
        }
    }

    // ---------- Camera setup ----------
    private fun startCamera() {
        val providerFuture = ProcessCameraProvider.getInstance(this)
        providerFuture.addListener({
            val provider = providerFuture.get()

            val preview = Preview.Builder().build().also {
                it.setSurfaceProvider(previewViewB.surfaceProvider)
            }

            imageCapture = ImageCapture.Builder()
                .setCaptureMode(ImageCapture.CAPTURE_MODE_MINIMIZE_LATENCY)
                .build()

            imageAnalysis = ImageAnalysis.Builder()
                .setBackpressureStrategy(ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)
                .build().apply {
                    val scanner = BarcodeScanning.getClient()
                    setAnalyzer(cameraExecutor) { proxy ->
                        analyzeForQr(scanner, proxy)
                    }
                }

            try {
                provider.unbindAll()
                provider.bindToLifecycle(
                    this,
                    CameraSelector.DEFAULT_BACK_CAMERA,
                    preview,
                    imageCapture,
                    imageAnalysis
                )
            } catch (t: Throwable) {
                Toast.makeText(this, "Camera error: ${t.message}", Toast.LENGTH_LONG).show()
                finish()
            }
        }, ContextCompat.getMainExecutor(this))
    }

    private fun analyzeForQr(
        scanner: com.google.mlkit.vision.barcode.BarcodeScanner,
        imageProxy: ImageProxy
    ) {
        val mediaImage = imageProxy.image ?: return imageProxy.close()
        if (analyzing.getAndSet(true)) { imageProxy.close(); return }

        val image = InputImage.fromMediaImage(mediaImage, imageProxy.imageInfo.rotationDegrees)
        scanner.process(image)
            .addOnSuccessListener { codes ->
                val value = codes.firstOrNull()?.rawValue
                if (!value.isNullOrBlank() && value != lastDecoded) {
                    lastDecoded = value
                    onDecoded(value)
                }
            }
            .addOnCompleteListener {
                analyzing.set(false)
                imageProxy.close()
            }
    }

    // Called once when a *new* QR code is seen
    private fun onDecoded(text: String) {
        if (navigated) return

        locationId = text.trim()
        runOnUiThread { txtScanValueB.text = locationId }

        // Take a quick photo snapshot; navigate afterwards
        capturePhotoThenNavigate()
    }

    // ---------- Capture still image ----------
    private fun capturePhotoThenNavigate() {
        val capture = imageCapture
        if (capture == null) { navigateToSummary(); return }

        val outputDir = getOutputDir()
        val fileName = SimpleDateFormat("yyyyMMdd_HHmmss", Locale.US)
            .format(System.currentTimeMillis()) + "_locB.jpg"
        val photoFile = File(outputDir, fileName)

        val outputOptions = ImageCapture.OutputFileOptions.Builder(photoFile).build()

        capture.takePicture(
            outputOptions,
            ContextCompat.getMainExecutor(this),
            object : ImageCapture.OnImageSavedCallback {
                override fun onError(exc: ImageCaptureException) {
                    // If capture fails, still proceed.
                    navigateToSummary()
                }

                override fun onImageSaved(result: ImageCapture.OutputFileResults) {
                    imageUri = result.savedUri ?: Uri.fromFile(photoFile)
                    runOnUiThread { imgPreviewB.setImageURI(imageUri) }
                    navigateToSummary()
                }
            }
        )
    }

    private fun getOutputDir(): File {
        val mediaDir = if (Build.VERSION.SDK_INT >= 29) {
            externalMediaDirs.firstOrNull()?.let { File(it, "captures").apply { mkdirs() } }
        } else {
            @Suppress("DEPRECATION")
            File(getExternalFilesDir(null), "captures").apply { mkdirs() }
        }
        return mediaDir ?: filesDir
    }

    // ---------- Handoff ----------
    private fun navigateToSummary() {
        if (navigated) return
        navigated = true

        if (gatewayId.isBlank() || bedId.isBlank() || locationId.isBlank()) {
            Toast.makeText(this, "Missing IDs", Toast.LENGTH_SHORT).show()
            finish()
            return
        }

        val i = Intent(this, SummaryBActivity::class.java).apply {
            putExtra(EXTRA_GATEWAY,  gatewayId)
            putExtra(EXTRA_BED,      bedId)
            putExtra(EXTRA_LOCATION, locationId)
            imageUri?.let { putExtra(EXTRA_IMAGE_URI, it.toString()) }
        }
        startActivity(i)
        finish()
    }

    override fun onDestroy() {
        super.onDestroy()
        imageAnalysis?.clearAnalyzer()
        cameraExecutor.shutdown()
    }
}




