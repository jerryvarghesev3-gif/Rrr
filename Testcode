ll



// File: TarUtils.kt (or whatever file you’re in)

// Treat both plain and encrypted tar.gz as “tar-gz like”
private const val TAR_GZ = ".tar.gz"
private const val TAR_GZ_ENC = ".tar.gz.enc"

private fun String.isTarGzLike(): Boolean {
    return endsWith(TAR_GZ, ignoreCase = true) ||
           endsWith(TAR_GZ_ENC, ignoreCase = true)
}





fun searchTarGzFile(
    tarStream: TarInputStream,
    searchFileName: String
): Outcome<ByteArray> {
    var outcome: Outcome<ByteArray> = Outcome.Error("SearchFileName not found")

    try {
        var entry = tarStream.nextEntry
        while (entry != null) {

            // 1) Direct file match
            if (entry.name == searchFileName) {
                val data = ByteArray(2048)
                var bytesRead: Int
                val b = ByteArrayOutputStream()

                while (tarStream.read(data).also { bytesRead = it } != -1) {
                    b.write(data, 0, bytesRead)
                }

                outcome = Outcome.Ok(b.toByteArray())
                break
            }
            // 2) Nested tar.gz / tar.gz.enc → recurse
            else if (entry.name.isTarGzLike()) {
                try {
                    val result = searchTarGzFile(
                        TarInputStream(
                            BufferedInputStream(
                                GZIPInputStream(tarStream)
                            )
                        ),
                        searchFileName
                    )

                    when (result) {
                        is Outcome.Ok -> {
                            outcome = result
                            break
                        }
                        is Outcome.Error -> {
                            // keep looking in other entries
                        }
                    }
                } catch (e: Exception) {
                    ProLog.e(MODULE_NAME, "searchTarGzFile inner exception = ${e}")
                }
            }

            entry = tarStream.nextEntry
        }
    } catch (e: Exception) {
        ProLog.e(MODULE_NAME, "searchTarGzFile outer exception = ${e}")
        outcome = Outcome.Error("Exception while searching for $searchFileName")
    }

    return outcome
}



