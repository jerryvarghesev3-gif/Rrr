package com.connect.connection

import android.content.Intent
import android.net.Uri
import android.os.Bundle
import android.view.View
import android.widget.Button
import android.widget.ImageView
import android.widget.ProgressBar
import android.widget.TextView
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity

// ---- MQTT (Paho) imports ----
// Use BOTH groups below in Gradle:
// implementation("info.mqtt.android:android-mqtt:2.1.1")
// implementation("org.eclipse.paho:org.eclipse.paho.client.mqttv3:1.2.5")
import info.mqtt.android.service.MqttAndroidClient
import org.eclipse.paho.client.mqttv3.IMqttActionListener
import org.eclipse.paho.client.mqttv3.IMqttDeliveryToken
import org.eclipse.paho.client.mqttv3.IMqttToken
import org.eclipse.paho.client.mqttv3.MqttCallbackExtended
import org.eclipse.paho.client.mqttv3.MqttMessage
import org.json.JSONObject

/**
 * Single-file tiny holder so you don't need extra files.
 * After you connect in your "Connect" screen, do:
 *     MqttBus.client = connectedClient
 */
object MqttBus {
    var client: MqttAndroidClient? = null
}

class SummaryBActivity : AppCompatActivity() {

    // ---- UI ----
    private lateinit var txtGateway: TextView
    private lateinit var txtBed: TextView
    private lateinit var txtLocation: TextView
    private lateinit var txtInfo: TextView
    private lateinit var imgPreview: ImageView
    private lateinit var btnBack: Button
    private lateinit var btnNext: Button
    private var progress: ProgressBar? = null   // optional; if not in XML we’ll just ignore

    // ---- data we show + send ----
    private var gatewayId: String = ""
    private var bedId: String = ""
    private var locationId: String = ""
    private var imageUri: Uri? = null

    // Remember to clean up later
    private var responseTopic: String? = null

    companion object {
        const val EXTRA_GATEWAY = "gatewayId"
        const val EXTRA_BED = "bedId"
        const val EXTRA_IMAGE_URI = "imageUri"
        const val EXTRA_LOCATION = "locationId"
    }

    // ------------- helpers -------------
    private fun onUi(block: () -> Unit) = runOnUiThread(block)

    private fun setUiBusy(busy: Boolean, msg: String = "") = onUi {
        progress?.visibility = if (busy) View.VISIBLE else View.GONE
        btnNext.isEnabled = !busy
        txtInfo.text = msg
    }

    private fun toast(msg: String) = onUi {
        Toast.makeText(this, msg, Toast.LENGTH_SHORT).show()
    }

    // topic helpers (match your previous app)
    private fun reqTopicFor(gw: String) = "gw/$gw/req/set_location"
    private fun respTopicFor(bed: String) = "bed/$bed/resp/set_location"

    // ------------- lifecycle -------------
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_summary_b)

        // bind
        txtGateway = findViewById(R.id.txtGatewayB)
        txtBed = findViewById(R.id.txtBedB)
        txtLocation = findViewById(R.id.txtLocationB)
        txtInfo = findViewById(R.id.txtInfoB)
        imgPreview = findViewById(R.id.imgPreviewB)
        btnBack = findViewById(R.id.btnBackB)
        btnNext = findViewById(R.id.btnNextB)
        progress = findViewById(R.id.progressB) // ok if not present

        // read extras
        gatewayId = intent.getStringExtra(EXTRA_GATEWAY).orEmpty()
        bedId = intent.getStringExtra(EXTRA_BED).orEmpty()
        locationId = intent.getStringExtra(EXTRA_LOCATION).orEmpty()
        intent.getStringExtra(EXTRA_IMAGE_URI)?.let { imageUri = Uri.parse(it) }

        // show
        txtGateway.text = "Gateway: $gatewayId"
        txtBed.text = "Bed ID: $bedId"
        txtLocation.text = "Location ID: $locationId"
        imageUri?.let { imgPreview.setImageURI(it) }

        btnBack.setOnClickListener { finish() }

        btnNext.setOnClickListener {
            if (gatewayId.isEmpty() || bedId.isEmpty() || locationId.isEmpty()) {
                toast("Missing IDs")
                return@setOnClickListener
            }
            // Pressing NEXT starts set_location
            subscribeForReplyAndSend(force = false)
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        try {
            // best-effort cleanup
            val c = MqttBus.client
            responseTopic?.let { topic -> c?.unsubscribe(topic) }
            c?.setCallback(null) // allowed by info.mqtt.android
        } catch (_: Exception) { }
    }

    // ------------- MQTT flow -------------
    private fun subscribeForReplyAndSend(force: Boolean) {
        val client = MqttBus.client ?: run {
            setUiBusy(false, "MQTT not connected")
            return
        }

        val resp = respTopicFor(bedId)
        responseTopic = resp

        // 1) Subscribe (idempotent if already subscribed server-side)
        client.subscribe(resp, /*qos*/1, /*userContext*/null, object : IMqttActionListener {
            override fun onSuccess(asyncActionToken: IMqttToken?) {
                // 2) After subscribing, install a callback that filters by our response topic
                client.setCallback(object : MqttCallbackExtended {
                    override fun connectComplete(reconnect: Boolean, serverURI: String?) {}
                    override fun connectionLost(cause: Throwable?) {
                        setUiBusy(false, "MQTT connection lost")
                    }
                    override fun messageArrived(topic: String?, message: MqttMessage?) {
                        if (topic == resp) {
                            val payload = message?.toString().orEmpty()
                            // Parse + navigate on main thread
                            onUi { handleSetLocationResponse(payload) }
                        }
                    }
                    override fun deliveryComplete(token: IMqttDeliveryToken?) {}
                })

                // Show waiting state and publish request
                setUiBusy(true, "Setting location…")
                publishSetLocation(force)
            }

            override fun onFailure(asyncActionToken: IMqttToken?, exception: Throwable?) {
                setUiBusy(false, "Subscribe failed: ${exception?.message}")
            }
        })
    }

    private fun publishSetLocation(force: Boolean) {
        val client = MqttBus.client ?: run {
            setUiBusy(false, "MQTT not connected")
            return
        }

        val reqTopic = reqTopicFor(gatewayId)

        val data = JSONObject().apply {
            put("bedId", bedId)
            put("locationId", locationId)
            put("force", force)
        }
        val req = JSONObject().apply {
            put("command", "set_location")
            put("data", data)
        }
        val payload = req.toString().toByteArray(Charsets.UTF_8)

        client.publish(reqTopic, payload, /*qos*/1, /*retained*/false, /*userContext*/null,
            object : IMqttActionListener {
                override fun onSuccess(asyncActionToken: IMqttToken?) {
                    // We simply keep waiting for the response topic
                    setUiBusy(true, "Sent… waiting for reply")
                }
                override fun onFailure(asyncActionToken: IMqttToken?, exception: Throwable?) {
                    setUiBusy(false, "Publish failed: ${exception?.message}")
                }
            })
    }

    private fun handleSetLocationResponse(json: String) {
        try {
            val root = JSONObject(json)
            val status = root.optInt("status", -1)

            // Some servers echo back the location under data.locationId; prefer it if present
            val locFromData = root.optJSONObject("data")?.optString("locationId").orEmpty()
            val finalLoc = if (locFromData.isNotBlank()) locFromData else locationId

            setUiBusy(false, if (status == 0) "Location set OK" else "set_location failed (status=$status)")

            // Navigate to your simple “Done” screen
            val i = Intent(this, SummaryActivity::class.java).apply {
                putExtra("gatewayId", gatewayId)
                putExtra("bedId", bedId)
                putExtra("locationId", finalLoc)
                putExtra("status", status)
                addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP or Intent.FLAG_ACTIVITY_SINGLE_TOP)
            }
            startActivity(i)
            finish()
        } catch (t: Throwable) {
            setUiBusy(false, "Response parse error: ${t.message}")
        }
    }
}

