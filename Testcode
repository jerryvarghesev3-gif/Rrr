void Firmware::updateBoard(quint32 destination, MEM_MEMORY_TYPE memoryType, QString binPath)
{
    updateComplete[destination]   = false;
    updateSuccessful[destination] = false;

    QString board = boardsList[destination];

    // ✅ keep correct types
    GN2_Address addressForUpdate = GN2A_MCB;                 // enum
    QString     serverBoard      = boardsList[GN2A_MCB];     // QString

    RPCA_Plant* rp = RPCA_Plant::getInstance();

    // existing special case (keep behavior)
    if ((!rp->isConnectedTo(GN2A_MCB)) && (destination == GN2A_ATLAS))
    {
        addressForUpdate = GN2A_ATLAS;
    }

    // ✅ serverBoard must come from boardsList using enum index
    serverBoard = boardsList[addressForUpdate];

    ProLog().i(MODULE_NAME, ("Firmware upgrade started on " + board).toStdString());

    // ---------------------------------------------------------------------
    // Decide image path + toggleBank  (KEEP YOUR EXISTING LOGIC)
    // ---------------------------------------------------------------------
    bool toggleBankOnCurrentBoard = false;

    QString somFileName = "N/A";
    QString tarPath;
    QString tarName;
    QString decryptFileName;
    QString decryptPath;

    if (MEM_MEMORY_TYPE_INTERNAL_FLASH == memoryType)
    {
        if (GN2A_SOM == destination)
        {
            // find dynamoSOMApp*.tar.gz.enc from your binariesFound list
            QRegularExpression tarRx("dynamoSOMApp*\\.tar\\.gz\\.enc");
            int32_t indexOfTarBinary = binariesFound.indexOf(tarRx);

            if (indexOfTarBinary > -1)
            {
                tarName = binariesFound.at(indexOfTarBinary);
                tarPath = binPath + "/" + tarName;

                // IMPORTANT: binPath must point to TAR for fwTar
                // (keep your old behavior: binPath gets tar appended)
                binPath = tarPath;

                somFileName = tarName;
            }

            // find decrypt if present (do NOT fail if missing)
            QRegularExpression decryptRx("^decrypt$");
            int32_t indexOfDecryptBinary = binariesFound.indexOf(decryptRx);
            if (indexOfDecryptBinary > -1)
            {
                decryptFileName = binariesFound.at(indexOfDecryptBinary);
                decryptPath = (binPath.left(binPath.lastIndexOf('/')) + "/" + decryptFileName);
                // if binPath was replaced with tarPath above, reconstruct folder:
                // decryptPath should be in same folder as tarPath
                decryptPath = tarPath.left(tarPath.lastIndexOf('/')) + "/" + decryptFileName;
            }
        }
        else
        {
            // your existing internal binaries behavior
            binPath.append("/");
            binPath.append(internalBinaries[destination]);
        }

        // Do not toggle banks if internal memory
        toggleBankOnCurrentBoard = false;
    }
    else if (MEM_MEMORY_TYPE_EXTERNAL_FLASH0 == memoryType)
    {
        toggleBankOnCurrentBoard = false;
        binPath.append("/");
        binPath.append(externalImages[destination]);
    }

    ProLog().i(MODULE_NAME, ("Image path: " + binPath).toStdString());

    // ---------------------------------------------------------------------
    // SOM SPECIAL: decrypt first, then tar (ONLY if decrypt exists)
    // ---------------------------------------------------------------------
    if (destination == GN2A_SOM && !decryptFileName.isEmpty())
    {
        ProLog().i(MODULE_NAME, "Uploading decrypt to SOM (first)");

        FirmwareUpdateCAN* fwDecrypt = new FirmwareUpdateCAN();
        fwDecrypt->setImageData(decryptPath);
        fwDecrypt->onChangedSelectedServer(addressForUpdate, serverBoard, NULL);
        fwDecrypt->setDestination(destination);

        // ✅ IMPORTANT: connect correct signature
        connect(fwDecrypt,
                &FirmwareUpdateCAN::imageUploadCompleted,
                this,
                [=](FirmwareUpdateCAN* /*fw*/, quint32 /*board*/, bool ok1)
                {
                    if (!ok1)
                    {
                        ProLog().w(MODULE_NAME, "Decrypt upload failed");
                        onBoardUpgraded(fwDecrypt, destination, false);
                        return;
                    }

                    ProLog().i(MODULE_NAME, "Decrypt upload OK, uploading tar.gz.enc to SOM (second)");

                    FirmwareUpdateCAN* fwTar = new FirmwareUpdateCAN();
                    fwTar->setImageData(tarPath); // ✅ tarPath, not decryptPath
                    fwTar->onChangedSelectedServer(addressForUpdate, serverBoard, NULL);
                    fwTar->setDestination(destination);

                    // send file name info to SOM for TAR (same as your original SOM flow)
                    MEM_SendImageFileNameRequest  req = MEM_SendImageFileNameRequest_init_zero;
                    MEM_SendImageFileNameResponse rsp = MEM_SendImageFileNameResponse_init_zero;
                    req.memoryType = memoryType;

                    const QByteArray nameBytes = tarName.toUtf8();
                    memset(req.imageName, 0, sizeof(req.imageName));
                    const int copyLen = qMin((int)sizeof(req.imageName) - 1, nameBytes.size());
                    memcpy(req.imageName, nameBytes.constData(), copyLen);

                    ProLog().i(MODULE_NAME, ("Downloading " + std::string(req.imageName) + " to SOM"));

                    if (CMD_OK != MEM_SendImageFileName(GN2A_SOM, &req, &rsp))
                    {
                        ProLog().w(MODULE_NAME, ("Could not send file info for " + tarName).toStdString());
                        onBoardUpgraded(fwTar, destination, false);
                        return;
                    }

                    // validate TAR (keep your behavior)
                    if (!fwTar->validateImage(memoryType, false))
                    {
                        ProLog().w(MODULE_NAME, ("Image verification failed on " + board).toStdString());
                        onBoardUpgraded(fwTar, destination, false);
                        return;
                    }

                    // ✅ correct connects (do NOT connect errorNotification to onBoardUpgraded)
                    connect(fwTar, &FirmwareUpdateCAN::imageUploadCompleted, this, &Firmware::onBoardUpgraded);
                    connect(fwTar, &FirmwareUpdateCAN::errorNotification,      this, &Firmware::onObservedError);
                    connect(fwTar, &FirmwareUpdateCAN::infoNotification,       this, &Firmware::onObservedInfo);
                    connect(fwTar, &FirmwareUpdateCAN::progressObserved,       this, &Firmware::onObservedProgress);
                    connect(fwTar, &FirmwareUpdateCAN::newProgressPhaseStarted,this, &Firmware::onPhaseChanged);
                    connect(this,  &Firmware::abortUpgrade,                    fwTar, &FirmwareUpdateCAN::abortUpgrade, Qt::DirectConnection);

                    currentMemoryType = memoryType;
                    fwTar->startUpdate(memoryType, false);
                },
                Qt::QueuedConnection);

        // ✅ decrypt connects (same pattern)
        connect(fwDecrypt, &FirmwareUpdateCAN::errorNotification,      this, &Firmware::onObservedError);
        connect(fwDecrypt, &FirmwareUpdateCAN::infoNotification,       this, &Firmware::onObservedInfo);
        connect(fwDecrypt, &FirmwareUpdateCAN::progressObserved,       this, &Firmware::onObservedProgress);
        connect(fwDecrypt, &FirmwareUpdateCAN::newProgressPhaseStarted,this, &Firmware::onPhaseChanged);
        connect(this,      &Firmware::abortUpgrade,                   fwDecrypt, &FirmwareUpdateCAN::abortUpgrade, Qt::DirectConnection);

        currentMemoryType = memoryType;
        fwDecrypt->startUpdate(memoryType, false);

        return; // ✅ SOM special path only when decrypt exists
    }

    // ---------------------------------------------------------------------
    // DEFAULT FLOW (no decrypt OR non-SOM): original behavior
    // ---------------------------------------------------------------------
    FirmwareUpdateCAN* fw = new FirmwareUpdateCAN();
    fw->setImageData(binPath);
    fw->onChangedSelectedServer(addressForUpdate, serverBoard, NULL);
    fw->setDestination(destination);

    // If SOM: send file name info (original behavior)
    if (GN2A_SOM == destination)
    {
        MEM_SendImageFileNameRequest  req = MEM_SendImageFileNameRequest_init_zero;
        MEM_SendImageFileNameResponse rsp = MEM_SendImageFileNameResponse_init_zero;
        req.memoryType = memoryType;

        const QByteArray nameBytes = somFileName.toUtf8();
        memset(req.imageName, 0, sizeof(req.imageName));
        const int copyLen = qMin((int)sizeof(req.imageName) - 1, nameBytes.size());
        memcpy(req.imageName, nameBytes.constData(), copyLen);

        ProLog().i(MODULE_NAME, ("Downloading " + std::string(req.imageName) + " to SOM"));

        if (CMD_OK != MEM_SendImageFileName(GN2A_SOM, &req, &rsp))
        {
            ProLog().w(MODULE_NAME, ("Could not send file info for " + somFileName).toStdString());
            onBoardUpgraded(fw, destination, false);
            return;
        }
    }

    // validate (keep your behavior)
    if (!fw->validateImage(memoryType, false))
    {
        ProLog().w(MODULE_NAME, ("Image verification failed on " + board).toStdString());
        onBoardUpgraded(fw, destination, false);
        return;
    }

    // ✅ correct connects
    connect(fw, &FirmwareUpdateCAN::imageUploadCompleted, this, &Firmware::onBoardUpgraded);
    connect(fw, &FirmwareUpdateCAN::errorNotification,      this, &Firmware::onObservedError);
    connect(fw, &FirmwareUpdateCAN::infoNotification,       this, &Firmware::onObservedInfo);
    connect(fw, &FirmwareUpdateCAN::progressObserved,       this, &Firmware::onObservedProgress);
    connect(fw, &FirmwareUpdateCAN::newProgressPhaseStarted,this, &Firmware::onPhaseChanged);
    connect(this, &Firmware::abortUpgrade, fw, &FirmwareUpdateCAN::abortUpgrade, Qt::DirectConnection);

    currentMemoryType = memoryType;
    fw->startUpdate(memoryType, toggleBankOnCurrentBoard);
}
