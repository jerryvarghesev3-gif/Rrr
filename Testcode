
package com.connect.connection

import android.Manifest
import android.content.ContentValues
import android.content.Intent
import android.content.pm.PackageManager
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.provider.MediaStore
import android.util.Log
import android.util.Size
import android.widget.Button
import android.widget.TextView
import android.widget.Toast
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AppCompatActivity
import androidx.camera.core.*
import androidx.camera.lifecycle.ProcessCameraProvider
import androidx.camera.view.PreviewView
import androidx.core.content.ContextCompat
import androidx.core.content.FileProvider
import com.google.mlkit.vision.barcode.BarcodeScannerOptions
import com.google.mlkit.vision.barcode.BarcodeScanning
import com.google.mlkit.vision.barcode.common.Barcode
import com.google.mlkit.vision.common.InputImage
import java.io.File
import java.text.SimpleDateFormat
import java.util.Locale
import java.util.concurrent.ExecutorService
import java.util.concurrent.Executors
import java.util.concurrent.atomic.AtomicBoolean

class BActivity : AppCompatActivity() {

    // Reuse keys from AActivity to avoid mismatches
    private val KEY_GATEWAY get() = AActivity.EXTRA_GATEWAY      // "gatewayId"
    private val KEY_BED     get() = AActivity.EXTRA_BED          // "bedId"
    private val KEY_IMG     get() = AActivity.EXTRA_IMAGE_URI    // "imageUri"

    // UI
    private lateinit var previewView: PreviewView
    private lateinit var txtScanValue: TextView
    private lateinit var btnRescan: Button
    private lateinit var btnContinue: Button
    private lateinit var btnCancel: Button

    // Data coming from previous screen(s)
    private var gatewayId: String = ""
    private var bedId: String = ""
    private var incomingImageUri: Uri? = null   // image forwarded from A (optional)

    // Captured in this screen
    private var locationId: String? = null

    // Camera / ML Kit
    private lateinit var cameraExecutor: ExecutorService
    private var imageCapture: ImageCapture? = null
    private var imageAnalysis: ImageAnalysis? = null
    private val analyzing = AtomicBoolean(true)
    private val navigating = AtomicBoolean(false)

    private val scannerOptions = BarcodeScannerOptions.Builder()
        .setBarcodeFormats(Barcode.FORMAT_QR_CODE) // Location QR
        .build()
    private val barcodeScanner by lazy { BarcodeScanning.getClient(scannerOptions) }

    // Permission
    private val requestCameraPerm = registerForActivityResult(
        ActivityResultContracts.RequestPermission()
    ) { granted ->
        if (granted) startCamera() else {
            Toast.makeText(this, "Camera permission denied", Toast.LENGTH_LONG).show()
            finish()
        }
    }

    @OptIn(ExperimentalGetImage::class)
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_qrb)   // make sure this XML has the expected IDs

        // Read what A/summaryA sent us
        gatewayId = intent.getStringExtra(KEY_GATEWAY).orEmpty()
        bedId     = intent.getStringExtra(KEY_BED).orEmpty()
        incomingImageUri = intent.getStringExtra(KEY_IMG)?.let { Uri.parse(it) }

        // Bind UI
        previewView   = findViewById(R.id.previewView)
        txtScanValue  = findViewById(R.id.txtScanValue)
        btnRescan     = findViewById(R.id.btnRescan)
        btnContinue   = findViewById(R.id.btnContinue)
        btnCancel     = findViewById(R.id.btnCancel)

        cameraExecutor = Executors.newSingleThreadExecutor()
        btnContinue.isEnabled = false

        btnRescan.setOnClickListener {
            locationId = null
            txtScanValue.text = ""
            analyzing.set(true)
            btnContinue.isEnabled = false
        }

        btnCancel.setOnClickListener { finish() }

        btnContinue.setOnClickListener {
            val loc = locationId?.trim().orEmpty()
            if (loc.isEmpty()) {
                Toast.makeText(this, "Scan Location QR first", Toast.LENGTH_SHORT).show()
                return@setOnClickListener
            }
            // Optional: capture a still photo here; if you don’t want a photo, call openSummaryB(null)
            takePhotoAndOpenSummaryB(loc)
        }

        // Permission → start
        if (ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA)
            == PackageManager.PERMISSION_GRANTED
        ) {
            startCamera()
        } else {
            requestCameraPerm.launch(Manifest.permission.CAMERA)
        }
    }

    @OptIn(ExperimentalGetImage::class)
    private fun startCamera() {
        val cameraProviderFuture = ProcessCameraProvider.getInstance(this)
        cameraProviderFuture.addListener({
            val cameraProvider = cameraProviderFuture.get()

            val preview = Preview.Builder()
                .setTargetRotation(previewView.display?.rotation ?: Surface.ROTATION_0)
                .build().also { it.setSurfaceProvider(previewView.surfaceProvider) }

            imageCapture = ImageCapture.Builder()
                .setCaptureMode(ImageCapture.CAPTURE_MODE_MINIMIZE_LATENCY)
                .setTargetRotation(previewView.display?.rotation ?: Surface.ROTATION_0)
                .build()

            imageAnalysis = ImageAnalysis.Builder()
                .setBackpressureStrategy(ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)
                .setTargetRotation(previewView.display?.rotation ?: Surface.ROTATION_0)
                .setTargetResolution(Size(1280, 720))
                .build().apply {
                    setAnalyzer(cameraExecutor) { proxy ->
                        val mediaImage = proxy.image
                        if (mediaImage == null) { proxy.close(); return@setAnalyzer }
                        if (!analyzing.get()) { proxy.close(); return@setAnalyzer }

                        val input = InputImage.fromMediaImage(
                            mediaImage, proxy.imageInfo.rotationDegrees
                        )

                        barcodeScanner.process(input)
                            .addOnSuccessListener { barcodes ->
                                val first = barcodes.firstOrNull()?.rawValue
                                if (!first.isNullOrBlank()) {
                                    // accept first decode & pause analyzer
                                    if (analyzing.compareAndSet(true, false)) {
                                        locationId = first.trim()
                                        runOnUiThread {
                                            txtScanValue.text = locationId
                                            btnContinue.isEnabled = true
                                        }
                                    }
                                }
                            }
                            .addOnFailureListener { e ->
                                Log.e("QR-B", "Scan failed", e)
                            }
                            .addOnCompleteListener {
                                proxy.close()
                            }
                    }
                }

            val selector = CameraSelector.DEFAULT_BACK_CAMERA
            cameraProvider.unbindAll()
            cameraProvider.bindToLifecycle(
                this, selector, preview, imageCapture, imageAnalysis
            )
        }, ContextCompat.getMainExecutor(this))
    }

    private fun takePhotoAndOpenSummaryB(loc: String) {
        val capture = imageCapture
        // If you don’t want a new photo on B, just forward incomingImageUri:
        if (capture == null) {
            openSummaryB(loc, incomingImageUri)
            return
        }

        // Save to MediaStore (gallery) on Android Q+, else use FileProvider
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
            val name = "loc_${SimpleDateFormat("yyyyMMdd_HHmmss", Locale.US).format(System.currentTimeMillis())}.jpg"
            val contentValues = ContentValues().apply {
                put(MediaStore.MediaColumns.DISPLAY_NAME, name)
                put(MediaStore.MediaColumns.MIME_TYPE, "image/jpeg")
                put(MediaStore.Images.Media.RELATIVE_PATH, "DCIM/Camera")
            }
            val output = ImageCapture.OutputFileOptions
                .Builder(contentResolver, MediaStore.Images.Media.EXTERNAL_CONTENT_URI, contentValues)
                .build()

            capture.takePicture(output, cameraExecutor, object : ImageCapture.OnImageSavedCallback {
                override fun onImageSaved(result: ImageCapture.OutputFileResults) {
                    val saved = result.savedUri
                    runOnUiThread { openSummaryB(loc, saved ?: incomingImageUri) }
                }
                override fun onError(e: ImageCaptureException) {
                    Log.e("QR-B", "Photo save error", e)
                    runOnUiThread { openSummaryB(loc, incomingImageUri) }
                }
            })
        } else {
            val imagesDir = File(cacheDir, "images").apply { mkdirs() }
            val photoFile = File(imagesDir, "loc_${System.currentTimeMillis()}.jpg")
            val uri = FileProvider.getUriForFile(
                this, "${applicationContext.packageName}.fileprovider", photoFile
            )
            val output = ImageCapture.OutputFileOptions.Builder(photoFile).build()
            capture.takePicture(output, cameraExecutor, object : ImageCapture.OnImageSavedCallback {
                override fun onImageSaved(result: ImageCapture.OutputFileResults) {
                    runOnUiThread { openSummaryB(loc, uri) }
                }
                override fun onError(e: ImageCaptureException) {
                    Log.e("QR-B", "Photo save error", e)
                    runOnUiThread { openSummaryB(loc, incomingImageUri) }
                }
            })
        }
    }

    private fun openSummaryB(loc: String, photo: Uri?) {
        if (!navigating.compareAndSet(false, true)) return

        // Stop analyzer & release camera before navigating
        try { imageAnalysis?.clearAnalyzer() } catch (_: Exception) {}
        try { ProcessCameraProvider.getInstance(this).get().unbindAll() } catch (_: Exception) {}

        val i = Intent(this, SummaryBActivity::class.java).apply {
            putExtra(KEY_GATEWAY, gatewayId)
            putExtra(KEY_BED, bedId)
            putExtra(EXTRA_LOCATION, loc)
            photo?.toString()?.let {
                putExtra(KEY_IMG, it)
                addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
            }
        }
        startActivity(i)
        // finish()   // optional: close BActivity to avoid back stack reuse with active camera
    }

    override fun onPause() {
        super.onPause()
        try { imageAnalysis?.clearAnalyzer() } catch (_: Exception) {}
    }

    override fun onDestroy() {
        super.onDestroy()
        try { ProcessCameraProvider.getInstance(this).get().unbindAll() } catch (_: Exception) {}
        try { cameraExecutor.shutdown() } catch (_: Exception) {}
    }

    companion object {
        const val EXTRA_LOCATION = "locationId" // keep for SummaryBActivity / SummaryActivity
    }
}





