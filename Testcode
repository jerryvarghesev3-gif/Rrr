// firmware.cpp

#include <algorithm>   // std::min
#include <cstring>     // memset, memcpy
#include <QPointer>
#include <QRegularExpression>

// Helper: send file name to SOM BEFORE starting upload (required by SOM side)
static bool sendSomFileName(
    quint32 destination,
    MEM_MEMORY_TYPE memoryType,
    const QString& fileName)
{
    if (destination != GN2A_SOM) return true;           // only SOM needs this
    if (fileName.isEmpty()) return false;

    MEM_SendImageFileNameRequest  req = MEM_SendImageFileNameRequest_init_zero;
    MEM_SendImageFileNameResponse rsp = MEM_SendImageFileNameResponse_init_zero;

    req.memoryType = memoryType;

    const QByteArray nameBytes = fileName.toUtf8();
    std::memset(req.imageName, 0, sizeof(req.imageName));

    const size_t copyLen = std::min(nameBytes.size(), (int)sizeof(req.imageName) - 1);
    std::memcpy(req.imageName, nameBytes.constData(), copyLen);

    if (CMD_OK != MEM_SendImageFileName(GN2A_SOM, &req, &rsp)) {
        return false;
    }
    return true;
}

void Firmware::updateBoard(quint32 destination, MEM_MEMORY_TYPE memoryType, QString binPath)
{
    updateComplete[destination]   = false;
    updateSuccessful[destination] = false;

    QString board = boardsList[destination];

    // ✅ IMPORTANT: keep types correct
    GN2_Address addressForUpdate = GN2A_MCB;   // enum
    QString     serverBoard      = GN2A_MCB;   // QString (board model string)
    RPCA_Plant* rp = RPCA_Plant::getInstance();

    // Existing special case (keep behavior): if not connected to MCB and updating ATLAS, use ATLAS
    if ((!rp->isConnectedTo(GN2A_MCB)) && (destination == GN2A_ATLAS)) {
        addressForUpdate = GN2A_ATLAS;
    }

    serverBoard = boardsList[addressForUpdate];

    ProLog().i(MODULE_NAME, ("Firmware upgrade started on " + board).toStdString());

    // ------------------------------------------------------------
    // Decide image path + toggleBank (matches your screenshots)
    // ------------------------------------------------------------
    bool toggleBankOnCurrentBoard = false;

    QString somFileName = "N/A";

    if (MEM_MEMORY_TYPE_INTERNAL_FLASH == memoryType)
    {
        // If SOM -> pick dynamoSOMApp*.tar.gz.enc from binariesFound
        if (GN2A_SOM == destination)
        {
            QRegularExpression tarRx(QStringLiteral("dynamoSOMApp.*\\.tar\\.gz\\.enc"));
            const int32_t indexOfTarBinary = binariesFound.indexOf(tarRx);

            if (indexOfTarBinary > -1) {
                somFileName = binariesFound.at(indexOfTarBinary);
                binPath.append("/");
                binPath.append(somFileName);
            } else {
                ProLog().w(MODULE_NAME, "Could not find dynamoSOMApp*.tar.gz.enc in binariesFound");
                onBoardUpgraded(nullptr, destination, false);
                return;
            }
        }
        else
        {
            // other boards -> internalBinaries
            binPath.append("/");
            binPath.append(internalBinaries[destination]);
        }

        // Do not toggle banks if internal memory.
        toggleBankOnCurrentBoard = false;
    }
    else if (MEM_MEMORY_TYPE_EXTERNAL_FLASH0 == memoryType)
    {
        toggleBankOnCurrentBoard = false;
        binPath.append("/");
        binPath.append(externalImages[destination]);
    }
    else
    {
        // keep your existing handling if you have more memory types
        toggleBankOnCurrentBoard = false;
        binPath.append("/");
        binPath.append(internalBinaries[destination]);
    }

    ProLog().i(MODULE_NAME, ("Image path: " + binPath).toStdString());

    // ------------------------------------------------------------
    // ✅ Minimal SOM fix: if decrypt exists, upload decrypt FIRST, then tar SECOND
    // ------------------------------------------------------------
    // decryptFileName / decryptPath are assumed already computed in your existing flow.
    // If you already have different variable names, map them:
    //   decryptFileName = name only (e.g., "decrypt")
    //   decryptPath     = full path (e.g., "<binFolder>/decrypt")
    //   tarPath         = full path (binPath)
    const QString tarPath = binPath;
    const QString tarName = QFileInfo(tarPath).fileName();

    const QString decryptName = decryptFileName; // <-- use your existing variable
    const QString decryptPath = decryptFullPath; // <-- use your existing variable

    if (destination == GN2A_SOM && !decryptName.isEmpty())
    {
        ProLog().i(MODULE_NAME, "Uploading decrypt to SOM (first)");

        // 1) upload decrypt
        FirmwareUpdateCAN* fwDecrypt = new FirmwareUpdateCAN();
        fwDecrypt->setImageData(decryptPath);
        fwDecrypt->onChangedSelectedServer(addressForUpdate, serverBoard, NULL);
        fwDecrypt->setDestination(destination);

        // Send decrypt filename to SOM
        if (!sendSomFileName(destination, memoryType, decryptName)) {
            ProLog().w(MODULE_NAME, "Could not send decrypt file info to SOM");
            onBoardUpgraded(fwDecrypt, destination, false);
            return;
        }

        // Keep your normal observers (use the RIGHT slots)
        connect(fwDecrypt, &FirmwareUpdateCAN::errorNotification, this, &Firmware::onObservedError);
        connect(fwDecrypt, &FirmwareUpdateCAN::infoNotification,  this, &Firmware::onObservedInfo);
        connect(fwDecrypt, &FirmwareUpdateCAN::progressObserved,  this, &Firmware::onObservedProgress);
        connect(fwDecrypt, &FirmwareUpdateCAN::newProgressPhaseStarted, this, &Firmware::onPhaseChanged);
        connect(this, &Firmware::abortUpgrade, fwDecrypt, &FirmwareUpdateCAN::abortUpgrade, Qt::DirectConnection);

        // Use QPointer so we don’t crash if something deletes the object later
        QPointer<FirmwareUpdateCAN> decryptPtr(fwDecrypt);

        connect(
            fwDecrypt,
            &FirmwareUpdateCAN::imageUploadCompleted,
            this,
            [=](FirmwareUpdateCAN* /*fw*/, quint32 /*board*/, bool ok1)
            {
                if (!decryptPtr) return;

                if (!ok1) {
                    ProLog().w(MODULE_NAME, "Decrypt upload failed");
                    onBoardUpgraded(decryptPtr, destination, false);
                    return;
                }

                ProLog().i(MODULE_NAME, "Uploading dynamoSOMApp.tar.gz.enc to SOM (second)");

                // 2) upload tar AFTER decrypt success
                FirmwareUpdateCAN* fwTar = new FirmwareUpdateCAN();
                fwTar->setImageData(tarPath);
                fwTar->onChangedSelectedServer(addressForUpdate, serverBoard, NULL);
                fwTar->setDestination(destination);

                // Send tar filename to SOM
                if (!sendSomFileName(destination, memoryType, tarName)) {
                    ProLog().w(MODULE_NAME, "Could not send tar file info to SOM");
                    onBoardUpgraded(fwTar, destination, false);
                    return;
                }

                connect(fwTar, &FirmwareUpdateCAN::errorNotification, this, &Firmware::onObservedError);
                connect(fwTar, &FirmwareUpdateCAN::infoNotification,  this, &Firmware::onObservedInfo);
                connect(fwTar, &FirmwareUpdateCAN::progressObserved,  this, &Firmware::onObservedProgress);
                connect(fwTar, &FirmwareUpdateCAN::newProgressPhaseStarted, this, &Firmware::onPhaseChanged);
                connect(this, &Firmware::abortUpgrade, fwTar, &FirmwareUpdateCAN::abortUpgrade, Qt::DirectConnection);

                QPointer<FirmwareUpdateCAN> tarPtr(fwTar);

                // ✅ IMPORTANT: only tar completion should call onBoardUpgraded(final result)
                connect(
                    fwTar,
                    &FirmwareUpdateCAN::imageUploadCompleted,
                    this,
                    [=](FirmwareUpdateCAN* /*fw*/, quint32 /*board*/, bool ok2)
                    {
                        if (!tarPtr) return;
                        onBoardUpgraded(tarPtr, destination, ok2);
                    },
                    Qt::QueuedConnection);

                currentMemoryType = memoryType;
                fwTar->startUpdate(memoryType, false);
            },
            Qt::QueuedConnection);

        currentMemoryType = memoryType;
        fwDecrypt->startUpdate(memoryType, false);
        return; // ✅ SOM special path ends here
    }

    // ------------------------------------------------------------
    // Normal path (all other boards, or SOM when decrypt is NOT present)
    // ------------------------------------------------------------
    FirmwareUpdateCAN* fw = new FirmwareUpdateCAN();
    fw->setImageData(binPath);
    fw->onChangedSelectedServer(addressForUpdate, serverBoard, NULL);
    fw->setDestination(destination);

    // For SOM even without decrypt, still send tar filename before starting
    if (destination == GN2A_SOM) {
        if (!sendSomFileName(destination, memoryType, tarName)) {
            ProLog().w(MODULE_NAME, "Could not send tar file info to SOM");
            onBoardUpgraded(fw, destination, false);
            return;
        }
    }

    // Keep your existing validation behavior
    if (!fw->validateImage(memoryType, false)) // do not check board version
    {
        ProLog().w(MODULE_NAME, ("Image Verification failed on " + board).toStdString());
        onBoardUpgraded(fw, destination, false);
        return;
    }

    connect(fw, &FirmwareUpdateCAN::imageUploadCompleted, this, &Firmware::onBoardUpgraded);
    connect(fw, &FirmwareUpdateCAN::errorNotification,   this, &Firmware::onObservedError);
    connect(fw, &FirmwareUpdateCAN::infoNotification,    this, &Firmware::onObservedInfo);
    connect(fw, &FirmwareUpdateCAN::progressObserved,    this, &Firmware::onObservedProgress);
    connect(fw, &FirmwareUpdateCAN::newProgressPhaseStarted, this, &Firmware::onPhaseChanged);
    connect(this, &Firmware::abortUpgrade, fw, &FirmwareUpdateCAN::abortUpgrade, Qt::DirectConnection);

    currentMemoryType = memoryType;
    fw->startUpdate(memoryType, toggleBankOnCurrentBoard);
}
