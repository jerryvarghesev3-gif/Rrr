void Firmware::updateBoard(quint32 destination, MEM_MEMORY_TYPE memoryType, QString binPath)
{
    updateComplete[destination]   = false;
    updateSuccessful[destination] = false;

    QString board = boardsList[destination];

    GN2_Address addressForUpdate = GN2A_MCB;
    QString serverBoard = GN2A_MCB;
    RPCA_Plant* rp = RPCA_Plant::getInstance();

    // existing special case (keep as you have)
    if ((!rp->isConnectedTo(GN2A_MCB)) && (destination == GN2A_ATLAS)) {
        addressForUpdate = GN2A_ATLAS;
    }
    serverBoard = boardsList[addressForUpdate];

    ProLog().i(MODULE_NAME, ("Firmware upgrade started on " + board).toStdString());

    // ------------------------------------------------------------
    // Decide image path + toggleBank (KEEP YOUR EXISTING LOGIC)
    // ------------------------------------------------------------
    bool toggleBankOnCurrentBoard = false;

    QString tarPath;
    QString tarName;
    QString decryptPath;
    QString decryptFileName; // empty if not present

    if (MEM_MEMORY_TYPE_INTERNAL_FLASH == memoryType)
    {
        // internal flash should not toggle bank (as in your screenshot)
        toggleBankOnCurrentBoard = false;

        // Default internal binary (your existing code)
        binPath.append("/");
        binPath.append(internalBinaries[destination]);

        // ------------------------------------------------------------
        // SOM special: choose tar.gz.enc from binariesFound (your screenshots)
        // ------------------------------------------------------------
        if (GN2A_SOM == destination)
        {
            // NOTE: You already have "binariesFound" in your function earlier.
            // This block assumes binariesFound is available (as in your screenshot).
            // If binariesFound is local above, keep it as-is.

            // --- find tar ---
            QRegularExpression tarRx("dynamoSOMApp.*\\.tar\\.gz\\.enc");
            int32_t indexOfTarBinary = binariesFound.indexOf(tarRx);

            if (indexOfTarBinary > -1) {
                tarName = binariesFound.at(indexOfTarBinary);
                tarPath = binPath + "/" + tarName;
            } else {
                // if tar not found, fallback to old behavior
                tarName.clear();
                tarPath = binPath;
            }

            // --- find decrypt (optional) ---
            // Use your actual decrypt naming pattern here if different
            QRegularExpression decRx("^decrypt$|decrypt(\\..*)?$");
            int32_t indexOfDecrypt = binariesFound.indexOf(decRx);
            if (indexOfDecrypt > -1) {
                decryptFileName = binariesFound.at(indexOfDecrypt);
                decryptPath     = binPath + "/" + decryptFileName;
            } else {
                decryptFileName.clear();
                decryptPath.clear();
            }
        }
    }
    else if (MEM_MEMORY_TYPE_EXTERNAL_FLASH0 == memoryType)
    {
        toggleBankOnCurrentBoard = false;
        binPath.append("/");
        binPath.append(externalImages[destination]);
    }

    ProLog().i(MODULE_NAME, ("Image path: " + binPath).toStdString());

    // ------------------------------------------------------------
    // Helper to attach your standard signals (minimal duplication)
    // ------------------------------------------------------------
    auto connectCommonSignals = [&](FirmwareUpdateCAN* fwObj)
    {
        connect(fwObj, &FirmwareUpdateCAN::errorNotification, this, &Firmware::onObservedError);
        connect(fwObj, &FirmwareUpdateCAN::infoNotification,  this, &Firmware::onObservedInfo);
        connect(fwObj, &FirmwareUpdateCAN::progressObserved,  this, &Firmware::onObservedProgress);
        connect(fwObj, &FirmwareUpdateCAN::newProgressPhaseStarted, this, &Firmware::onPhaseChanged);

        connect(this, &Firmware::abortUpgrade,
                fwObj, &FirmwareUpdateCAN::abortUpgrade,
                Qt::DirectConnection);
    };

    // ------------------------------------------------------------
    // ✅ SOM SPECIAL PATH:
    // decrypt first, tar second (only if decrypt exists)
    // ------------------------------------------------------------
    if (destination == GN2A_SOM && !decryptFileName.isEmpty())
    {
        // 1) upload decrypt
        FirmwareUpdateCAN* fwDecrypt = new FirmwareUpdateCAN();
        fwDecrypt->setImageData(decryptPath);
        fwDecrypt->onChangedSelectedServer(addressForUpdate, serverBoard, NULL);
        fwDecrypt->setDestination(destination);

        connectCommonSignals(fwDecrypt);

        connect(fwDecrypt,
                &FirmwareUpdateCAN::imageUploadCompleted,
                this,
                [=](FirmwareUpdateCAN* /*fw*/, quint32 /*board*/, bool ok1)
                {
                    if (!ok1) {
                        // fail immediately
                        onBoardUpgraded(fwDecrypt, destination, false);
                        return;
                    }

                    // 2) upload tar.gz.enc AFTER decrypt success
                    FirmwareUpdateCAN* fwTar = new FirmwareUpdateCAN();
                    fwTar->setImageData(tarPath);
                    fwTar->onChangedSelectedServer(addressForUpdate, serverBoard, NULL);
                    fwTar->setDestination(destination);

                    connectCommonSignals(fwTar);

                    // IMPORTANT: only tar completion decides final result
                    connect(fwTar,
                            &FirmwareUpdateCAN::imageUploadCompleted,
                            this,
                            [=](FirmwareUpdateCAN* /*fw*/, quint32 /*board*/, bool ok2)
                            {
                                onBoardUpgraded(fwTar, destination, ok2);
                            },
                            Qt::QueuedConnection);

                    // (Optional but recommended for SOM) tell SOM which file to expect (tarName)
                    // If you already do this below, keep that logic instead.
                    if (!tarName.isEmpty()) {
                        MEM_SendImageFileNameRequest req = MEM_SendImageFileNameRequest_init_zero;
                        MEM_SendImageFileNameResponse rsp = MEM_SendImageFileNameResponse_init_zero;
                        req.memoryType = memoryType;

                        const QByteArray nameBytes = tarName.toUtf8();
                        memset(req.imageName, 0, sizeof(req.imageName));
                        const int copyLen = (int)qMin((qsizetype)sizeof(req.imageName) - 1, nameBytes.size());
                        memcpy(req.imageName, nameBytes.constData(), copyLen);

                        ProLog().i(MODULE_NAME,
                                   ("Downloading " + std::string(req.imageName) + " to SOM").c_str());

                        if (CMD_OK != MEM_SendImageFileName(GN2A_SOM, &req, &rsp)) {
                            ProLog().w(MODULE_NAME, ("Could not send file info to " + board).toStdString());
                            onBoardUpgraded(fwTar, destination, false);
                            return;
                        }
                    }

                    fwTar->startUpdate(memoryType, false);
                },
                Qt::QueuedConnection);

        fwDecrypt->startUpdate(memoryType, false);
        return; // ✅ SOM handled completely here
    }

    // ------------------------------------------------------------
    // Normal flow (including SOM without decrypt)
    // ------------------------------------------------------------
    FirmwareUpdateCAN* fw = new FirmwareUpdateCAN();
    fw->setImageData(binPath);
    fw->onChangedSelectedServer(addressForUpdate, serverBoard, NULL);
    fw->setDestination(destination);

    // validation (keep yours)
    if (!fw->validateImage(memoryType, false)) {
        ProLog().w(MODULE_NAME, ("Image Verification failed on " + board).toStdString());
        onBoardUpgraded(fw, destination, false);
        return;
    }

    // correct signature connect
    connect(fw, &FirmwareUpdateCAN::imageUploadCompleted, this, &Firmware::onBoardUpgraded);
    connectCommonSignals(fw);

    currentMemoryType = memoryType;
    fw->startUpdate(memoryType, toggleBankOnCurrentBoard);
}
